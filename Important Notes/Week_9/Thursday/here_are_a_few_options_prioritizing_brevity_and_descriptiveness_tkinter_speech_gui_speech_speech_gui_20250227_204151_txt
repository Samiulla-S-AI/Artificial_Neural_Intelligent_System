Date: 2025-02-27 20:41:51
--------------------------------------------------

import tkinter as tk
from tkinter import ttk, scrolledtext, Label, Frame, Button,Entry, Text, END, NORMAL, DISABLED, WORD,Canvas, Tk, filedialog
import pyttsx3
import datetime
import speech_recognition as sr
import webbrowser
import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import time
import math
import threading
import logging
import screen_brightness_control as sbc
import keyboard
import pyautogui
from PIL import Image, ImageGrab
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import psutil
from tkinter import messagebox
from deep_translator import GoogleTranslator
import urllib.parse
import sys
import random
import platform
import subprocess
import importlib
from pathlib import Path
import sqlite3
import google.generativeai as genai
from PIL import Image
from urllib.parse import quote
import shutil
import re

# Get the application directory
def get_app_directory():
    try:
        home = str(Path.home())
        app_dir = os.path.join(home, "VoiceAssistant")
        return app_dir
    except Exception as e:
        print(f"Error getting app directory: {str(e)}")
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), "VoiceAssistant")

def ensure_directory_exists(directory):
    try:
        os.makedirs(directory, exist_ok=True)
        return True
    except Exception as e:
        print(f"Error creating directory {directory}: {str(e)}")
        return False

def get_log_directory():
    try:
        app_dir = get_app_directory()
        log_dir = os.path.join(app_dir, "logs")
        return log_dir
    except Exception as e:
        print(f"Error getting log directory: {str(e)}")
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), "logs")

def setup_logging():
    try:
        # Create log directory
        log_dir = get_log_directory()
        if not ensure_directory_exists(log_dir):
            print("Warning: Failed to create log directory. Using basic console logging.")
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[logging.StreamHandler()]
            )
            return False

        # Setup logging configuration
        log_file = os.path.join(log_dir, "voice_assistant.log")
        
        # Configure logging with both file and console handlers
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        
        logging.info("Logging initialized successfully")
        return True

    except Exception as e:
        print(f"Warning: Error in logging setup: {str(e)}. Using basic console logging.")
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[logging.StreamHandler()]
        )
        return False

def create_required_directories():
    try:
        app_dir = get_app_directory()
        required_dirs = {
            'app': app_dir,
            'logs': os.path.join(app_dir, "logs"),
            'data': os.path.join(app_dir, "data"),
            'config': os.path.join(app_dir, "config"),
            'temp': os.path.join(app_dir, "temp")
        }

        success = True
        for dir_name, dir_path in required_dirs.items():
            if not ensure_directory_exists(dir_path):
                print(f"Warning: Failed to create {dir_name} directory at {dir_path}")
                success = False

        return success
    except Exception as e:
        print(f"Error creating required directories: {str(e)}")
        return False

# Initialize text-to-speech engine
engine = pyttsx3.init('sapi5')
voices = engine.getProperty('voices')
engine.setProperty('voice', voices[0].id)  # Set default voice

# Initialize the model and tokenizer globally for faster access
  

class WaveVisualizer(tk.Canvas):
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self.configure(bg='#000000')  # Black background
        self.is_active = True
        self.animation_running = False
        self.after_id = None
        self._lock = threading.Lock()
        self.particles = []
        self.colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF']  # Rainbow colors
        
        # Initialize particles
        self.init_particles()
        
    def init_particles(self):
        """Initialize particles for the visualization"""
        self.particles = []
        num_particles = 50
        for i in range(num_particles):
            angle = (2 * math.pi * i) / num_particles
            self.particles.append({
                'angle': angle,
                'radius': 20,
                'speed': 0.1 + random.random() * 0.2,
                'color': random.choice(self.colors),
                'size': random.randint(2, 5)
            })
            
    def speaking_animation(self):
        if not self.is_active or self.animation_running:
            return
            
        def _animate():
            if not self.is_active or not self.animation_running:
                return False
            try:
                with self._lock:
                    self.delete("wave")
                    width = self.winfo_width()
                    height = self.winfo_height()
                    center_x = width / 2
                    center_y = height / 2
                    current_time = time.time()
                    
                    # Update and draw particles
                    for particle in self.particles:
                        # Update particle position
                        particle['radius'] += math.sin(current_time * 2) * 0.5
                        particle['angle'] += particle['speed']
                        
                        # Calculate position
                        x = center_x + particle['radius'] * math.cos(particle['angle']) * 5
                        y = center_y + particle['radius'] * math.sin(particle['angle']) * 5
                        
                        # Draw particle with glow effect
                        size = particle['size'] * (1 + math.sin(current_time * 4) * 0.3)
                        glow_size = size * 2
                        
                        # Create glow effect
                        self.create_oval(
                            x - glow_size, y - glow_size,
                            x + glow_size, y + glow_size,
                            fill='', outline=particle['color'],
                            width=1, tags="wave",
                            stipple='gray50'
                        )
                        
                        # Create main particle
                        self.create_oval(
                            x - size, y - size,
                            x + size, y + size,
                            fill=particle['color'],
                            outline='',
                            tags="wave"
                        )
                        
                        # Add connecting lines between particles
                        if random.random() < 0.3:  # 30% chance to draw a line
                            next_particle = random.choice(self.particles)
                            next_x = center_x + next_particle['radius'] * math.cos(next_particle['angle']) * 5
                            next_y = center_y + next_particle['radius'] * math.sin(next_particle['angle']) * 5
                            self.create_line(
                                x, y, next_x, next_y,
                                fill=particle['color'],
                                width=1,
                                tags="wave",
                                stipple='gray50'
                            )
                    
                    return True
            except tk.TclError:
                self.is_active = False
                return False
            except Exception as e:
                logging.error(f"Animation error: {str(e)}")
                return False

        def animate_loop():
            if _animate():
                self.after_id = self.after(30, animate_loop)
            else:
                self.animation_running = False
                self.after_id = None

        with self._lock:
            if not self.animation_running and self.is_active:
                self.animation_running = True
                self.after_id = self.after(30, animate_loop)
            
    def start_listening_animation(self):
        if not self.is_active or self.animation_running:
            return
            
        def _animate():
            if not self.is_active or not self.animation_running:
                return False
            try:
                with self._lock:
                    self.delete("wave")
                    width = self.winfo_width()
                    height = self.winfo_height()
                    center_x = width / 2
                    center_y = height / 2
                    current_time = time.time()
                    
                    # Draw circular waves
                    max_radius = min(width, height) / 3
                    num_circles = 8
                    
                    for i in range(num_circles):
                        radius = (max_radius * (i + 1) / num_circles) + (math.sin(current_time * 2) * 10)
                        color = self.colors[i % len(self.colors)]
                        
                        # Create pulsing circle
                        self.create_oval(
                            center_x - radius, center_y - radius,
                            center_x + radius, center_y + radius,
                            outline=color,
                            width=2,
                            tags="wave"
                        )
                        
                        # Add rotating dots on the circle
                        for j in range(8):
                            angle = (2 * math.pi * j / 8) + current_time * 2
                            dot_x = center_x + radius * math.cos(angle)
                            dot_y = center_y + radius * math.sin(angle)
                            dot_size = 3 + math.sin(current_time * 4 + j) * 2
                            
                            self.create_oval(
                                dot_x - dot_size, dot_y - dot_size,
                                dot_x + dot_size, dot_y + dot_size,
                                fill=color,
                                outline='',
                                tags="wave"
                            )
                    
                    return True
            except tk.TclError:
                self.is_active = False
                return False
            except Exception as e:
                logging.error(f"Animation error: {str(e)}")
                return False

        def animate_loop():
            if _animate():
                self.after_id = self.after(30, animate_loop)
            else:
                self.animation_running = False
                self.after_id = None

        with self._lock:
            if not self.animation_running and self.is_active:
                self.animation_running = True
                self.after_id = self.after(30, animate_loop)
            
    def stop_listening_animation(self):
        with self._lock:
            self.animation_running = False
            if self.after_id:
                self.after_cancel(self.after_id)
                self.after_id = None
            if self.is_active:
                try:
                    self.delete("wave")
                except tk.TclError:
                    self.is_active = False

    def cleanup(self):
        """Clean up the visualizer before window destruction"""
        with self._lock:
            self.is_active = False
            self.animation_running = False
            if self.after_id:
                self.after_cancel(self.after_id)
                self.after_id = None
            try:
                self.delete("all")
            except tk.TclError:
                pass

class VoiceAssistant:
    def __init__(self, root):
        self.root = root
        self.programming_window = None
        self.root.title("A.N.I.S AI Assistant")
        self.root.geometry("900x900")
        
        # Create main container with padding
        self.main_container = tk.Frame(
            self.root,
            bg='#0a0a1f',
            padx=30,
            pady=20
        )
        self.main_container.pack(fill=tk.BOTH, expand=True)
        
        # Create banner frame
        self.banner_frame = tk.Frame(
            self.main_container,
            bg='#0a0a1f',
            height=100
        )
        self.banner_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Create gradient frame for wave visualizer
        self.gradient_frame = tk.Frame(
            self.main_container,
            bg='#0a0a1f',
            highlightbackground='#2a2a4a',
            highlightthickness=2,
            bd=0
        )
        self.gradient_frame.pack(fill=tk.X, pady=20)
        
        # Inner frame with glass effect
        self.wave_frame = tk.Frame(
            self.gradient_frame,
            bg='#0a0a1f',
            bd=0
        )
        self.wave_frame.pack(fill=tk.X, padx=15, pady=15)
        
        # Initialize themes
        self.themes = {
            "Dark Blue": {
                 "bg": "#0D0221",
                "fg": "#00FF9F",
                "accent": "#FF2975",
                "secondary": "#2DE2E6",
                "highlight": "#261447",
                "text_bg": "#0F0326",
                "success": "#00FF9F",
                "error": "#FF2975"
            },
            "Cyberpunk": {
                  "bg": "#0a0a1f",
                "fg": "#e2e2e2",
                "accent": "#4361ee",
                "secondary": "#8f9aff",
                "highlight": "#2a2a4a",
                "text_bg": "#12122a",
                "success": "#4CAF50",
                "error": "#ff4d4d"
            },
            "Forest": {
                "bg": "#1A2F1D",
                "fg": "#C7F9CC",
                "accent": "#57BA5E",
                "secondary": "#80ED99",
                "highlight": "#2D4A31",
                "text_bg": "#1F3823",
                "success": "#57BA5E",
                "error": "#FF6B6B"
            },
            "Ocean": {
                "bg": "#0A192F",
                "fg": "#E6F1FF",
                "accent": "#64FFDA",
                "secondary": "#8892B0",
                "highlight": "#172A45",
                "text_bg": "#0C1B2B",
                "success": "#64FFDA",
                "error": "#FF647F"
            },
            "Tron Legacy": {
                "bg": "#0C141F",
                "fg": "#00F2FF",
                "accent": "#15f4ee",
                "secondary": "#2a2a4a",
                "highlight": "#2a2a4a",
                "text_bg": "#12122a",
                "success": "#4CAF50",
                "error": "#ff4d4d"
            }
        }
        
        # Set default theme
        self.current_theme = "Dark Blue"
        
        
        # Add wave visualizer with enhanced size and glass effect
        self.wave_vis = WaveVisualizer(
            self.wave_frame, 
            width=820,
            height=150,
            bg='#000000',
            bd=0,
            highlightthickness=1,
            highlightbackground='#2a2a4a'
        )
        self.wave_vis.pack(pady=5)
        
        # Create main interface
        self.create_gui()
        
        # Apply theme after GUI is created
        self.apply_theme(self.current_theme)
        
        # Add cleanup binding
        self.root.protocol("WM_DELETE_WINDOW", self.exit_assistant)
        self.contact_manager =  None
        self.initialize_database()

        try:
            import google.generativeai as genai
            genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            self.gemini_model = genai.GenerativeModel('gemini-2.0-flash')
            self.chat = self.gemini_model.start_chat(history=[])
        except Exception as e:
            self.handle_errors(e, "Error initializing Gemini API")

    def _initialize_task_system(self):
        """Initialize the task scheduling system and recover any pending tasks"""
        try:
            # Ensure database exists
            self.initialize_database()
            
            # Connect to the database
            db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Get all pending tasks
            cursor.execute('''SELECT id, task, execution_time, status 
                            FROM scheduled_tasks 
                            WHERE status = 'scheduled' AND completed = 0''')
            pending_tasks = cursor.fetchall()
            
            # Close the connection
            conn.close()
            
            # Reschedule pending tasks
            now = datetime.datetime.now()
            for task_id, task, execution_time_str, status in pending_tasks:
                try:
                    # Parse the execution time
                    execution_time = datetime.datetime.strptime(execution_time_str, '%Y-%m-%d %H:%M:%S')
                    
                    # Calculate seconds until execution
                    time_diff = (execution_time - now).total_seconds()
                    
                    # If the task is in the future, reschedule it
                    if time_diff > 0:
                        logging.info(f"Rescheduling task {task_id}: '{task}' to run in {time_diff:.1f} seconds")
                        
                        # Create a timer for this task
                        timer_key = f"task_{task_id}"
                        timer = threading.Timer(time_diff, lambda t=task, tid=task_id: self.execute_task(t, tid))
                        timer.daemon = True
                        self._task_timers[timer_key] = timer
                        timer.start()
                    else:
                        # Task was scheduled in the past, mark it as missed
                        logging.warning(f"Task {task_id}: '{task}' was scheduled for {execution_time_str} but was missed")
                        conn = sqlite3.connect(db_path)
                        cursor = conn.cursor()
                        cursor.execute('''UPDATE scheduled_tasks 
                                        SET status = 'missed' 
                                        WHERE id = ?''', (task_id,))
                        conn.commit()
                        conn.close()
                except Exception as e:
                    logging.error(f"Error rescheduling task {task_id}: {str(e)}")
            
            # Set up periodic cleanup of expired tasks
            self._schedule_task_cleanup()
            
        except Exception as e:
            logging.error(f"Error initializing task system: {str(e)}")
    
    def _schedule_task_cleanup(self):
        """Schedule periodic cleanup of expired tasks"""
        try:
            # Clean up expired tasks
            self._cleanup_expired_tasks()
            
            # Schedule the next cleanup in 1 hour
            if hasattr(self, 'root') and self.root.winfo_exists():
                self.root.after(3600000, self._schedule_task_cleanup)  # 3600000 ms = 1 hour
        except Exception as e:
            logging.error(f"Error scheduling task cleanup: {str(e)}")
    
    def _cleanup_expired_tasks(self):
        """Clean up expired tasks from the database"""
        try:
            # Connect to the database
            db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Get current time
            now = datetime.datetime.now()
            
            # Find tasks that are more than 24 hours old and not completed
            one_day_ago = (now - datetime.timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S')
            
            # Mark old scheduled tasks as expired
            cursor.execute('''UPDATE scheduled_tasks 
                            SET status = 'expired' 
                            WHERE status = 'scheduled' 
                            AND execution_time < ? 
                            AND completed = 0''', (one_day_ago,))
            
            # Count affected rows
            expired_count = cursor.rowcount
            
            # Commit changes and close connection
            conn.commit()
            conn.close()
            
            if expired_count > 0:
                logging.info(f"Cleaned up {expired_count} expired tasks")
                
        except Exception as e:
            logging.error(f"Error cleaning up expired tasks: {str(e)}")
            
        return True
    def create_gui(self):
        # Top control frame for play button and time
        top_control_frame = Frame(
            self.main_container,
            bg='#0a0a1f',
            height=60  # Increased height
        )
        top_control_frame.pack(fill=tk.X, pady=(0, 10))
        top_control_frame.pack_propagate(False)
        
        # System stats frame (left side)
        stats_frame = Frame(
            top_control_frame,
            bg='#0a0a1f'
        )
        stats_frame.pack(side=tk.LEFT, padx=20)
        
        # CPU Usage
        self.cpu_label = Label(
            stats_frame,
            text="CPU: 0%",
            font=("Segoe UI", 10),
            bg='#0a0a1f',
            fg='#8f9aff'
        )
        self.cpu_label.pack(side=tk.LEFT, padx=(0, 15))
        
        # Memory Usage
        self.memory_label = Label(
            stats_frame,
            text="RAM: 0%",
            font=("Segoe UI", 10),
            bg='#0a0a1f',
            fg='#8f9aff'
        )
        self.memory_label.pack(side=tk.LEFT, padx=(0, 15))
        
        # Time label
        self.time_label = Label(
            stats_frame,
            text="",
            font=("Segoe UI", 10),
            bg='#0a0a1f',
            fg='#8f9aff'
        )
        self.time_label.pack(side=tk.LEFT)
        self.update_time()
        
        # Control buttons container (right side)
        control_buttons_frame = Frame(
            top_control_frame,
            bg='#0a0a1f'
        )
        control_buttons_frame.pack(side=tk.RIGHT, padx=20)
        
        # Settings button
        self.settings_button = Button(
            control_buttons_frame,
            text="⚙",
            font=('Segoe UI', 16),
            bg='#0a0a1f',
            fg='#8f9aff',
            bd=0,
            relief='flat',
            cursor='hand2',
            command=self.show_settings
        )
        self.settings_button.pack(side=tk.RIGHT, padx=(10, 0))
        
        # Play button container with glow effect
        play_container = Frame(
            control_buttons_frame,
            bg='#0a0a1f',
            padx=2,
            pady=2,
            highlightbackground='#00ff00',
            highlightthickness=2
        )
        play_container.pack(side=tk.RIGHT, padx=10)
        
        # Create circular play button with animation effects
        self.start_button = Button(
            play_container,
            text="▶",
            command=self.toggle_listening,
            font=('Segoe UI', 16, 'bold'),
            bg='#00ff00',
            fg='#000000',
            activebackground='#00cc00',
            activeforeground='#000000',
            width=3,
            height=1,
            bd=0,
            relief='flat',
            cursor='hand2'
        )
        self.start_button.pack(padx=2, pady=2)

        # Add microphone animation frame
        self.mic_frame = Frame(
            self.main_container,
            bg='#0a0a1f',
            height=30
        )
        self.mic_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Microphone animation dots
        self.mic_dots = []
        for i in range(10):
            dot = Label(
                self.mic_frame,
                text="●",
                font=("Segoe UI", 8),
                bg='#0a0a1f',
                fg='#1f1f3f'  # Start with dark color
            )
            dot.pack(side=tk.LEFT, padx=2)
            self.mic_dots.append(dot)

        # Initialize state variables
        self.start_button._clicked = False
        self.start_button._listening = False
        self.listening_thread = None
        
        # Start system stats update
        self.update_system_stats()
        
        # Modern header with gradient and glow effect
        self.header_label = Label(
            self.banner_frame, 
            text="A.N.I.S",
            font=("Segoe UI", 48, "bold"),
            bg='#0a0a1f',
            fg='#4361ee'
        )
        self.header_label.pack(pady=(10, 0))
        
        # Subtitle
        self.subtitle_label = Label(
            self.banner_frame,
            text="Artificial Neural Intelligence System",
            font=("Segoe UI Light", 14),
            bg='#0a0a1f',
            fg='#8f9aff'
        )
        self.subtitle_label.pack()
        
        # Status label with modern font and glow effect
        self.status_frame = tk.Frame(self.main_container, bg='#0a0a1f')
        self.status_frame.pack(fill=tk.X, pady=10)
        
        self.status_label = Label(
            self.status_frame,
            text="● Not Listening",
            font=("Segoe UI", 12),
            bg='#0a0a1f',
            fg='#ff4d4d'  # Red when not listening
        )
        self.status_label.pack(side=tk.LEFT, padx=20)
        
        # Output text area with modern styling and glass effect
        text_container = tk.Frame(
            self.main_container,
            bg='#0a0a1f',
            highlightbackground='#2a2a4a',
            highlightthickness=1,
            bd=0
        )
        text_container.pack(fill=tk.BOTH, expand=True, pady=20)
        
        # Inner padding frame with rounded corners
        text_frame = tk.Frame(
            text_container,
            bg='#0a0a1f',
            padx=2,
            pady=2
        )
        text_frame.pack(fill=tk.BOTH, expand=True)
        
        # Custom style for the scrollbar
        style = ttk.Style()
        style.configure(
            "Custom.Vertical.TScrollbar",
            background='#4361ee',
            troughcolor='#1a1a35',
            width=10,
            arrowsize=0
        )
        
        # Create scrolled text widget with modern styling
        self.output_text = scrolledtext.ScrolledText(
            text_frame,
            wrap=WORD,
            height=22,
            width=80,
            bg='#12122a',
            fg='#e2e2e2',
            font=("JetBrains Mono", 10),
            bd=0,
            padx=15,
            pady=10,
            insertbackground='#4361ee',
            selectbackground='#4361ee',
            selectforeground='#ffffff',
            relief='flat',
            cursor='ibeam'
        )
        self.output_text.pack(padx=3, pady=3)
        
        # Configure tags for different message types
        self.output_text.tag_configure(
            "user_msg", 
            foreground="#4CAF50",
            font=("JetBrains Mono", 10, "bold")
        )
        self.output_text.tag_configure(
            "assistant_msg", 
            foreground="#4361ee",
            font=("JetBrains Mono", 10)
        )
        self.output_text.tag_configure(
            "time_stamp", 
            foreground="#666666",
            font=("JetBrains Mono", 8)
        )
        
        # Modify the text insertion methods to use the new tags
        def insert_with_timestamp(self, text, tag):
            timestamp = datetime.datetime.now().strftime("%H:%M:%S")
            self.output_text.config(state=NORMAL)
            self.output_text.insert(END, f"[{timestamp}] ", "time_stamp")
            self.output_text.insert(END, f"{text}\n", tag)
            self.output_text.config(state=DISABLED)
            self.output_text.see(END)
            
        # Bind the method to the class
        self.insert_with_timestamp = insert_with_timestamp.__get__(self)

    def update_time(self):
        """Update the time display"""
        try:
            if hasattr(self, 'time_label') and self.time_label.winfo_exists():
                current_time = datetime.datetime.now().strftime("%I:%M:%S %p")
                self.time_label.config(text=current_time)
                self._after_id = self.root.after(1000, self.update_time)
        except Exception as e:
            logging.error(f"Error updating time: {str(e)}")
            # Don't schedule another update if there was an error
            return
        
    def update_status(self, is_listening=False):
        """Update the status label safely"""
        try:
            if hasattr(self, 'status_label') and self.status_label.winfo_exists():
                if is_listening:
                    self.status_label.config(
                        text="● Listening",
                        fg='#4CAF50'  # Green when listening
                    )
                else:
                    self.status_label.config(
                        text="● Not Listening",
                        fg='#ff4d4d'  # Red when not listening
                    )
        except tk.TclError:
            pass  # Ignore if widget is destroyed

    def type_and_enter(self, command):
        """Type the text at cursor position with minimal delay"""
        try:
            if command.startswith('type '):
                text = command[5:].strip()
                if text:
                    self.typing_active = True
                    self.status_label.config(text="Typing Mode Active")
                    pyautogui.typewrite(text, interval=0.01)  # Faster typing
                    self.speak('Done')
                else:
                    self.speak('Please provide text to type')
        except Exception as e:
            logging.error(f"Error in typing: {str(e)}")
            self.speak("Error typing")
    def get_website_url(self, website_name):
        """Get website URL using the URL database or Gemini API."""
        # First, check if the URL is already stored in the database
        url = get_url(website_name)
        if url:
            return url  # Return the URL if found in the database

        # If not found, use the Gemini API to fetch the URL
        try:
            prompt = f"What is the login URL for {website_name}? Only return the direct URL, no other text or explanation."
            response = self.gemini_model.generate_content(prompt)
            url = response.text.strip()

            # Store the fetched URL in the database for future access
            add_url(website_name, url)
            return url
        except Exception as e:
            logging.error(f"Error getting website URL: {str(e)}")
            return None

    def auto_login(self, website):
        """Auto login to the specified website."""
        try:
            # Get website URL using Gemini API
            retry_attempts = 3
            for attempt in range(retry_attempts):
                try:
                    website_url = self.get_website_url(website)
                    if website_url:
                        break
                    else:
                        if attempt < retry_attempts - 1:
                            self.speak("Could not find login URL. Retrying...")
                            time.sleep(2)  # Wait before retrying
                        else:
                            self.speak("Could not find login URL after multiple attempts.")
                            return
                except Exception as e:
                    logging.error(f"Error getting website URL: {str(e)}")
                    if attempt < retry_attempts - 1:
                        self.speak("Connection error. Retrying...")
                        time.sleep(2)  # Wait before retrying
                    else:
                        self.speak("Could not connect after multiple attempts.")
                        return

            # Fetch credentials from the database
            conn = sqlite3.connect('auto_login.db')
            cursor = conn.cursor()
            cursor.execute('SELECT email, password FROM credentials WHERE website = ?', (website.lower(),))
            result = cursor.fetchone()
            conn.close()

            if result:
                email, password = result
                # Use Selenium to perform the login
                driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
                driver.get(website_url)
                
                try:
                    # Increase wait time for better reliability
                    wait = WebDriverWait(driver, 0.1)
                    
                    # Common selectors for email/username field
                    email_selectors = [
                        (By.NAME, "email"),
                        (By.NAME, "username"),
                        (By.ID, "email"),
                        (By.ID, "username"),
                        (By.CSS_SELECTOR, "input[type='email']"),
                        (By.CSS_SELECTOR, "input[type='text']"),
                        (By.XPATH, "//input[@placeholder='Email' or @placeholder='Username' or contains(@placeholder, 'email') or contains(@placeholder, 'username')]"),
                    ]

                    # Common selectors for password field
                    password_selectors = [
                        (By.NAME, "password"),
                        (By.ID, "password"),
                        (By.CSS_SELECTOR, "input[type='password']"),
                        (By.XPATH, "//input[@placeholder='Password' or contains(@placeholder, 'password')]"),
                    ]

                    # Common selectors for next/continue buttons
                    next_selectors = [
                        (By.XPATH, "//button[contains(text(), 'Next') or contains(text(), 'Continue')]"),
                        (By.XPATH, "//div[contains(text(), 'Next') or contains(text(), 'Continue')]"),
                        (By.XPATH, "//span[contains(text(), 'Next') or contains(text(), 'Continue')]"),
                        (By.CSS_SELECTOR, "button[type='submit']"),
                        (By.NAME, "next"),
                        (By.ID, "next"),
                        (By.ID, "identifierNext"),  # Google specific
                        (By.ID, "passwordNext")     # Google specific
                    ]

                    # Common selectors for final login buttons
                    login_selectors = [
                        (By.CSS_SELECTOR, "button[type='submit']"),
                        (By.NAME, "login"),
                        (By.ID, "login"),
                        (By.XPATH, "//button[contains(text(), 'Login') or contains(text(), 'Sign in')]"),
                        (By.XPATH, "//input[@type='submit' or @value='Login' or @value='Sign in']")
                    ]

                    def find_and_click_element(selectors, timeout=1):
                        """Find and click an element using multiple selectors"""
                        for by, selector in selectors:
                            try:
                                element = wait.until(EC.element_to_be_clickable((by, selector)))
                                element.click()
                                return element
                            except:
                                continue
                        return None

                    def find_and_fill_element(selectors, text, timeout=1):
                        """Find and fill an element using multiple selectors"""
                        for by, selector in selectors:
                            try:
                                element = wait.until(EC.presence_of_element_located((by, selector)))
                                element.clear()
                                element.send_keys(text)
                                return element
                            except:
                                continue
                        return None

                    # Step 1: Find and fill email field
                    email_field = find_and_fill_element(email_selectors, email)
                    if not email_field:
                        self.speak("Could not find email field")
                        driver.quit()
                        return

                    # Look for and click next button (for multi-step login)
                    next_button = find_and_click_element(next_selectors)
                    if next_button:
                        time.sleep(0.1)  # Wait for transition

                    # Step 2: Find and fill password field
                    password_field = find_and_fill_element(password_selectors, password)
                    if not password_field:
                        # If password field is not found, wait and check again
                        time.sleep(5)  # Wait for the page to load
                        password_field = find_and_fill_element(password_selectors, password)
                        if not password_field:
                            self.speak("Could not find password field. Please check your login process.")
                            driver.quit()
                            return

                    # Try final login button
                    login_button = find_and_click_element(login_selectors)
                    if not login_button:
                        # If no login button, try next button again (for Google-style login)
                        next_button = find_and_click_element(next_selectors)
                        if not next_button:
                            self.speak("Could not find login button")
                            driver.quit()
                            return

                    # Wait for login to complete
                    time.sleep(7)

                    # Check for common error indicators
                    error_texts = ['invalid', 'incorrect', 'failed', 'error', 'wrong']
                    page_source = driver.page_source.lower();
                    
                    if any(error_text in page_source for error_text in error_texts):
                        self.speak("Login in")
                        self.show_password_manager(website)
                        driver.quit()
                    else:
                        self.speak("Login successful!")
                        # Keep the browser window open for the user

                except Exception as e:
                    logging.error(f"Error during login process: {str(e)}")
                    self.speak("")
                    driver.quit()

            else:
                self.speak(f"No credentials found for {website}. Opening password manager to add them.")
                self.show_password_manager(website)

        except Exception as e:
            logging.error(f"Error during auto login: {str(e)}")
            self.speak("An error occurred during the auto login process.")

    def show_password_manager(self, website=None):
        """Show password manager window."""
        try:
            password_window = tk.Toplevel(self.root)
            password_window.title("Password Manager")
            password_window.geometry("400x300")
            password_window.configure(bg=self.themes[self.current_theme]["bg"])

            # Website entry
            tk.Label(
                password_window, 
                text="Website:",
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["fg"]
            ).pack(pady=5)
            
            website_entry = tk.Entry(password_window, width=30)
            website_entry.pack(pady=5)
            if website:
                website_entry.insert(0, website)

            # Email entry
            tk.Label(
                password_window,
                text="Email:",
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["fg"]
            ).pack(pady=5)
            
            email_entry = tk.Entry(password_window, width=30)
            email_entry.pack(pady=5)

            # Password entry
            tk.Label(
                password_window,
                text="Password:",
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["fg"]
            ).pack(pady=5)
            
            password_entry = tk.Entry(password_window, width=30, show="*")
            password_entry.pack(pady=5)

            def save_credentials():
                try:
                    website = website_entry.get().strip().lower()
                    email = email_entry.get().strip()
                    password = password_entry.get().strip()

                    if website and email and password:
                        conn = sqlite3.connect('auto_login.db')
                        cursor = conn.cursor()
                        cursor.execute('''
                            INSERT OR REPLACE INTO credentials (website, email, password)
                            VALUES (?, ?, ?)
                        ''', (website, email, password))
                        conn.commit()
                        conn.close()
                        self.speak("Credentials saved successfully!")
                        password_window.destroy()
                    else:
                        self.speak("Please fill in all fields.")
                except Exception as e:
                    logging.error(f"Error saving credentials: {str(e)}")
                    self.speak("Error saving credentials.")

            # Save button
            save_btn = tk.Button(
                password_window,
                text="Save Credentials",
                command=save_credentials,
                bg=self.themes[self.current_theme]["accent"],
                fg="white"
            )
            save_btn.pack(pady=20)

        except Exception as e:
            logging.error(f"Error showing password manager: {str(e)}")
            self.speak("Error opening password manager.")
    def show_chat_window(self):
        """Show the Gemini chat window"""
        try:
            # First check if Gemini API is available
            try:
                import google.generativeai as genai
                genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            except ImportError:
                self.speak("Please install the google-generativeai package first")
                messagebox.showerror("Missing Dependency", 
                    "Please install the required package:\npip install google-generativeai")
                return

            # Create and show the chat window
            chat_window = GeminiChatWindow(self)
            
            # Make window modal
            chat_window.window.transient(self.root)
            chat_window.window.grab_set()
            
        except Exception as e:
            self.handle_errors(e, "Error opening chat window")
            self.speak("Sorry, I encountered an error while opening the chat window.")
    def stop_typing(self):
        """Stop typing mode"""
        self.typing_active = False
        self.status_label.config(text="Listening...")
    def parse_duration(self, duration_str):
        """Parse duration string into seconds"""
        try:
            duration_str = duration_str.lower()
            total_seconds = 0
            
            # Handle "after X" format
            if duration_str.startswith('after'):
                duration_str = duration_str[5:].strip()
                
            # Extract numbers and units
            parts = duration_str.split()
            number = None
            for i, part in enumerate(parts):
                if part.isdigit():
                    number = int(part)
                    if i + 1 < len(parts):
                        unit = parts[i + 1].lower()
                        if 'hour' in unit:
                            total_seconds += number * 3600
                        elif 'min' in unit:
                            total_seconds += number * 60
                        elif 'sec' in unit:
                            total_seconds += number
                            
            return total_seconds
        except Exception as e:
            logging.error(f"Error parsing duration: {str(e)}")
            return 0

    def show_task_scheduler(self, preset_time=None, preset_tasks=None):
        """Show task scheduler window with improved task execution"""
        scheduler_window = tk.Toplevel(self.root)
        scheduler_window.title("Task Scheduler")
        scheduler_window.geometry("600x700")
        scheduler_window.configure(bg=self.themes[self.current_theme]["bg"])
        
        # Make window modal
        scheduler_window.transient(self.root)
        scheduler_window.grab_set()
        
        # Create main container
        main_frame = Frame(
            scheduler_window,
            bg=self.themes[self.current_theme]["bg"],
            padx=20,
            pady=20
        )
        main_frame.pack(fill='both', expand=True)
        
        # Title
        Label(
            main_frame,
            text="Schedule Tasks",
            font=("Segoe UI", 16, "bold"),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["accent"]
        ).pack(pady=(0, 20))
        
        # Time selection frame
        time_frame = Frame(main_frame, bg=self.themes[self.current_theme]["bg"])
        time_frame.pack(fill='x', pady=10)
        
        Label(
            time_frame,
            text="Time until tasks (seconds):",
            font=("Segoe UI", 12),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(side='left', padx=(0, 10))
        
        time_var = tk.StringVar(value=str(preset_time) if preset_time else "60")
        time_entry = ttk.Entry(
            time_frame,
            textvariable=time_var,
            font=("Segoe UI", 12),
            width=10
        )
        time_entry.pack(side='left')

        # Task selection frame
        task_frame = Frame(main_frame, bg=self.themes[self.current_theme]["bg"])
        task_frame.pack(fill='both', expand=True, pady=20)
        
        Label(
            task_frame,
            text="Selected Tasks:",
            font=("Segoe UI", 12),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(anchor='w')

        # Create task list with scrollbar
        task_list_frame = Frame(task_frame, bg=self.themes[self.current_theme]["bg"])
        task_list_frame.pack(fill='both', expand=True, pady=10)
        
        task_listbox = tk.Listbox(
            task_list_frame,
            bg=self.themes[self.current_theme]["text_bg"],
            fg=self.themes[self.current_theme]["fg"],
            font=("Segoe UI", 11),
            selectmode='multiple',
            relief='flat',
            bd=1,
            highlightthickness=1,
            highlightbackground=self.themes[self.current_theme]["accent"]
        )
        task_listbox.pack(side='left', fill='both', expand=True)

        # Add scrollbar
        scrollbar = ttk.Scrollbar(task_list_frame, orient='vertical', command=task_listbox.yview)
        scrollbar.pack(side='right', fill='y')
        task_listbox.config(yscrollcommand=scrollbar.set)

        # Add predefined tasks
        predefined_tasks = [
            "Check system health",
            "Take screenshot",
            "Create backup",
            "Open notes",
            "Open contact manager",
            "Data analysis",
            "Save notes",
            "Open Word",
            "Open Excel",
            "Open PowerPoint"
        ]
        
        # Custom tasks frame
        custom_frame = Frame(main_frame, bg=self.themes[self.current_theme]["bg"])
        custom_frame.pack(fill='x', pady=20)
        
        Label(
            custom_frame,
            text="Enter custom commands or select files:",
            font=("Segoe UI", 12),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(anchor='w')
        
        custom_entry = ttk.Entry(
            custom_frame,
            font=("Segoe UI", 12),
            width=40
        )
        custom_entry.pack(fill='x', pady=5)

        # First add preset tasks if provided
        if preset_tasks:
            # Split and normalize the preset tasks, removing duplicates
            seen_tasks = set()
            unique_tasks = []
            
            # First split by comma
            initial_tasks = [t.strip() for t in preset_tasks.split(',') if t.strip()]
            
            # Further process each task to handle cases where commands are stuck together
            for task in initial_tasks:
                # Split tasks that might be stuck together (e.g., "open notepad open google")
                sub_tasks = []
                if task.lower().startswith('open '):
                    # Split by 'open' and process each part
                    parts = task.lower().split('open ')
                    for part in parts:
                        if part.strip():
                            sub_tasks.append(f"open {part.strip()}")
                else:
                    sub_tasks.append(task)
                
                # Add each sub-task if it's unique
                for sub_task in sub_tasks:
                    normalized_task = sub_task.lower().strip()
                    if normalized_task not in seen_tasks:
                        seen_tasks.add(normalized_task)
                        # Preserve the original case of the first word (e.g., "Open")
                        if sub_task.lower().startswith('open '):
                            words = sub_task.split(' ', 1)
                            if len(words) > 1:
                                sub_task = f"Open {words[1]}"
                        unique_tasks.append(sub_task)
            
            # Add only unique tasks to the listbox
            for task in unique_tasks:
                if task not in task_listbox.get(0, 'end'):  # Additional check to avoid duplicates with predefined tasks
                    task_listbox.insert('end', task)
                    last_index = task_listbox.size() - 1
                    task_listbox.selection_set(last_index)
            
            # Update custom entry with deduplicated tasks
            custom_entry.delete(0, 'end')  # Clear any existing text
            custom_entry.insert(0, ','.join(unique_tasks))

        # Then add predefined tasks
        for task in predefined_tasks:
            if task not in task_listbox.get(0, 'end'):  # Avoid duplicates
                task_listbox.insert('end', task)

        # File paths storage
        file_paths = []

        def browse_file():
            file_path = filedialog.askopenfilename(
                title="Select a file to schedule",
                filetypes=(
                    ("All Files", "*.*"),
                    ("Text Files", "*.txt"),
                    ("Word Documents", "*.doc;*.docx"),
                    ("Excel Files", "*.xls;*.xlsx"),
                    ("PDF Files", "*.pdf")
                )
            )
            if file_path:
                # Store the full path
                file_paths.append(file_path)
                # Add to listbox with just the filename for display
                filename = os.path.basename(file_path)
                task_listbox.insert('end', f"Open {filename}")
                task_listbox.selection_set('end')

        # Add file browser button
        Button(
            custom_frame,
            text="Browse File",
            command=browse_file,
            bg=self.themes[self.current_theme]["accent"],
            fg="#ffffff",
            font=('Segoe UI', 10),
            relief='flat'
        ).pack(side='right', padx=5)

        def schedule_tasks():
            try:
                seconds = int(time_var.get())
                selected_indices = task_listbox.curselection()
                
                # Validate time input
                if seconds <= 0:
                    messagebox.showerror("Error", "Please enter a positive number of seconds")
                    return
                
                # Collect tasks from both selection and custom entry
                tasks = []
                seen_tasks = set()  # Track unique tasks
                
                # Get tasks from custom entry if provided
                custom_task = custom_entry.get().strip()
                if custom_task:
                    # Split and process custom tasks
                    custom_parts = custom_task.split(',')
                    for part in custom_parts:
                        task = part.strip()
                        if task:
                            normalized_task = task.lower()
                            if normalized_task not in seen_tasks:
                                seen_tasks.add(normalized_task)
                                tasks.append(task)
                
                # Get tasks from selection
                if selected_indices:
                    for index in selected_indices:
                        task_text = task_listbox.get(index)
                        normalized_task = task_text.lower()
                        if task_text.startswith("Open "):
                            # Handle file paths
                            file_idx = index - (task_listbox.size() - len(file_paths))
                            if 0 <= file_idx < len(file_paths):
                                file_task = f"open_file:{file_paths[file_idx]}"
                                if file_task.lower() not in seen_tasks:
                                    seen_tasks.add(file_task.lower())
                                    tasks.append(file_task)
                        else:
                            if normalized_task not in seen_tasks:
                                seen_tasks.add(normalized_task)
                                tasks.append(task_text)
                
                # Validate we have tasks to schedule
                if not tasks:
                    messagebox.showerror("Error", "Please select tasks or enter custom commands")
                    return
                
                # Join all tasks with commas and store as a single entry
                combined_tasks = ','.join(tasks)
                logging.info(f"Scheduling combined tasks: {combined_tasks}")
                
                # Check if this exact task set is already scheduled
                db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                
                # Look for pending tasks with the same content
                cursor.execute('''SELECT id, execution_time FROM scheduled_tasks 
                                WHERE task = ? AND status = 'scheduled' AND completed = 0''', 
                                (combined_tasks,))
                existing_task = cursor.fetchone()
                
                if existing_task:
                    task_id, execution_time = existing_task
                    response = messagebox.askyesno(
                        "Duplicate Task", 
                        f"This exact task is already scheduled to run at {execution_time}.\nDo you want to schedule it again?"
                    )
                    if not response:
                        conn.close()
                        return
                
                conn.close()
                
                # Store the task in the database
                task_id = self.store_scheduled_task(seconds, combined_tasks)
                
                if task_id:
                    # Calculate exact execution time
                    execution_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
                    
                    # Create a timer that will execute at the exact time
                    # Use a unique identifier for each timer to prevent duplicates
                    timer_key = f"task_{task_id}"
                    
                    # Cancel any existing timer with the same key
                    if hasattr(self, '_task_timers') and timer_key in self._task_timers:
                        old_timer = self._task_timers[timer_key]
                        if old_timer.is_alive():
                            logging.info(f"Cancelling existing timer for task ID {task_id}")
                            old_timer.cancel()
                    
                    # Initialize the task timers dictionary if it doesn't exist
                    if not hasattr(self, '_task_timers'):
                        self._task_timers = {}
                    
                    # Create and store the new timer
                    timer = threading.Timer(seconds, lambda t=combined_tasks, tid=task_id: self.execute_task(t, tid))
                    timer.daemon = True
                    self._task_timers[timer_key] = timer
                    timer.start()
                    
                    # Format the execution time for display
                    time_str = execution_time.strftime("%I:%M:%S %p")
                    messagebox.showinfo("Success", f"Scheduled {len(tasks)} task(s) to run at {time_str}")
                    scheduler_window.destroy()
                else:
                    messagebox.showerror("Error", "Failed to store scheduled tasks")
            except ValueError:
                messagebox.showerror("Error", "Please enter a valid number of seconds")
            except Exception as e:
                logging.error(f"Error scheduling tasks: {str(e)}")
                messagebox.showerror("Error", f"Failed to schedule tasks: {str(e)}")

        # Schedule button
        Button(
            main_frame,
            text="Schedule Tasks",
            command=schedule_tasks,
            bg=self.themes[self.current_theme]["accent"],
            fg="#ffffff",
            font=('Segoe UI', 12, 'bold'),
            width=15,
            height=1,
            relief='flat',
            cursor='hand2'
        ).pack(pady=20)

    def execute_task(self, task_name, task_id):
        """Execute a scheduled task with support for file opening and multiple tasks"""
        try:
            db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # First, check if this task has already been executed or is in progress
            cursor.execute('''SELECT status, completed FROM scheduled_tasks 
                            WHERE id = ?''', (task_id,))
            task_info = cursor.fetchone()
            
            if not task_info:
                logging.error(f"Task ID {task_id} not found in database")
                return
                
            status, completed = task_info
            
            # If the task is already completed or in progress, don't execute it again
            if completed == 1 or status in ['executing', 'completed']:
                logging.warning(f"Task {task_id} has already been {status}. Skipping execution.")
                return
            
            # Create a global execution lock for this task ID if it doesn't exist
            if not hasattr(self, '_task_execution_locks'):
                self._task_execution_locks = {}
                
            # Check if this task is already being executed
            if task_id in self._task_execution_locks:
                logging.warning(f"Task {task_id} is already being executed. Preventing duplicate execution.")
                return
                
            # Set execution lock
            self._task_execution_locks[task_id] = True
            
            try:
                # Update status to executing
                cursor.execute('''UPDATE scheduled_tasks 
                                SET status = 'executing' 
                                WHERE id = ?''', (task_id,))
                conn.commit()
                
                # Log the task execution
                logging.info(f"Executing scheduled task: '{task_name}' (ID: {task_id})")
                
                # Check if this is a multi-task entry (comma-separated tasks)
                if ',' in task_name:
                    # Split the tasks and execute each one
                    tasks = [t.strip() for t in task_name.split(',') if t.strip()]
                    logging.info(f"Found {len(tasks)} tasks to execute: {tasks}")
                    
                    # Track executed tasks to prevent duplicates
                    executed_tasks = set()
                    
                    for individual_task in tasks:
                        # Skip if this exact task has already been executed in this batch
                        if individual_task in executed_tasks:
                            logging.info(f"Skipping duplicate task: '{individual_task}'")
                            continue
                            
                        logging.info(f"Executing sub-task: '{individual_task}'")
                        executed_tasks.add(individual_task)
                        
                        # Pre-process the task to check if it's a compound command
                        compound_commands = self._parse_compound_command(individual_task)
                        if len(compound_commands) > 1:
                            logging.info(f"Detected compound command with {len(compound_commands)} parts: {compound_commands}")
                            # Track executed compound commands
                            executed_commands = set()
                            for cmd in compound_commands:
                                # Skip duplicate commands within the compound command
                                if cmd in executed_commands:
                                    logging.info(f"Skipping duplicate command part: '{cmd}'")
                                    continue
                                    
                                executed_commands.add(cmd)
                                self.speak(f"task: {cmd}")
                                try:
                                    self._execute_direct_command(cmd)
                                    time.sleep(1.5)  # Small delay between commands
                                except Exception as e:
                                    logging.error(f"Error executing compound command part '{cmd}': {str(e)}")
                                    self.speak(f"Error executing task: {cmd}")
                                    
                                    # Try fallback for "open" commands
                                    if cmd.startswith('open '):
                                        try:
                                            app_name = cmd.replace('open ', '', 1).strip()
                                            self.speak(f"Trying to search for {app_name} instead")
                                            self.search_and_click_first_result(app_name)
                                        except Exception as search_error:
                                            logging.error(f"Fallback search failed for '{app_name}': {str(search_error)}")
                            continue
                        
                        # Handle file opening tasks
                        if individual_task.startswith('open_file:'):
                            self._execute_file_task(individual_task)
                        else:
                            # Process regular command - use the direct command execution
                            self.speak(f"task: {individual_task}")
                            try:
                                self._execute_direct_command(individual_task)
                                # Small delay between tasks to prevent overlap
                                time.sleep(2)
                            except Exception as e:
                                logging.error(f"Error executing sub-task '{individual_task}': {str(e)}")
                                self.speak(f"Error executing task: {individual_task}")
                                
                                # Try fallback for "open" commands
                                if individual_task.startswith('open '):
                                    try:
                                        app_name = individual_task.replace('open ', '', 1).strip()
                                        self.speak(f"Trying to search for {app_name} instead")
                                        self.search_and_click_first_result(app_name)
                                    except Exception as search_error:
                                        logging.error(f"Fallback search failed for '{app_name}': {str(search_error)}")
                else:
                    # Process single task - check if it's a compound command first
                    compound_commands = self._parse_compound_command(task_name)
                    if len(compound_commands) > 1:
                        logging.info(f"Detected compound command with {len(compound_commands)} parts: {compound_commands}")
                        # Track executed commands
                        executed_commands = set()
                        for cmd in compound_commands:
                            # Skip duplicate commands
                            if cmd in executed_commands:
                                logging.info(f"Skipping duplicate command part: '{cmd}'")
                                continue
                                
                            executed_commands.add(cmd)
                            self.speak(f"Executing scheduled task: {cmd}")
                            try:
                                self._execute_direct_command(cmd)
                                time.sleep(1.5)  # Small delay between commands
                            except Exception as e:
                                logging.error(f"Error executing compound command part '{cmd}': {str(e)}")
                                self.speak(f"Error executing task: {cmd}")
                                
                                # Try fallback for "open" commands
                                if cmd.startswith('open '):
                                    try:
                                        app_name = cmd.replace('open ', '', 1).strip()
                                        self.speak(f"Trying to search for {app_name} instead")
                                        self.search_and_click_first_result(app_name)
                                    except Exception as search_error:
                                        logging.error(f"Fallback search failed for '{app_name}': {str(search_error)}")
                    elif task_name.startswith('open_file:'):
                        # Extract the file path
                        self._execute_file_task(task_name)
                    else:
                        # Handle other types of tasks
                        self.speak(f"task: {task_name}")
                        try:
                            self._execute_direct_command(task_name)
                        except Exception as e:
                            logging.error(f"Error executing task '{task_name}': {str(e)}")
                            self.speak(f"Error executing task: {task_name}")
                            
                            # Try fallback for "open" commands
                            if task_name.startswith('open '):
                                try:
                                    app_name = task_name.replace('open ', '', 1).strip()
                                    self.speak(f"search for {app_name} instead")
                                    self.search_and_click_first_result(app_name)
                                except Exception as search_error:
                                    logging.error(f"Fallback search failed for '{app_name}': {str(search_error)}")
                
                # Update status to completed
                cursor.execute('''UPDATE scheduled_tasks 
                                SET status = 'completed', 
                                completed = 1 
                                WHERE id = ?''', (task_id,))
                conn.commit()
                
                # Clean up the timer reference if it exists
                if hasattr(self, '_task_timers'):
                    timer_key = f"task_{task_id}"
                    if timer_key in self._task_timers:
                        del self._task_timers[timer_key]
            
            finally:
                # Always release the execution lock
                if hasattr(self, '_task_execution_locks') and task_id in self._task_execution_locks:
                    del self._task_execution_locks[task_id]
            
        except Exception as e:
            logging.error(f"Error executing task '{task_name}' (ID: {task_id}): {str(e)}")
            try:
                conn = sqlite3.connect(db_path)
                cursor = conn.cursor()
                cursor.execute('''UPDATE scheduled_tasks 
                                SET status = 'failed' 
                                WHERE id = ?''', (task_id,))
                conn.commit()
                
                # Release the execution lock in case of error
                if hasattr(self, '_task_execution_locks') and task_id in self._task_execution_locks:
                    del self._task_execution_locks[task_id]
                    
            except Exception as inner_e:
                logging.error(f"Error updating failed task status: {str(inner_e)}")
        finally:
            if 'conn' in locals():
                conn.close()
                
    def _execute_file_task(self, task_name):
        """Helper method to execute file-opening tasks"""
        file_path = task_name.replace('open_file:', '', 1)
        if os.path.exists(file_path):
            try:
                if file_path.lower().endswith('.txt'):
                    subprocess.Popen(['notepad.exe', file_path])
                else:
                    os.startfile(file_path)
                self.speak(f"Opening {os.path.basename(file_path)}")
            except Exception as e:
                logging.error(f"Error opening file {file_path}: {str(e)}")
                self.speak(f"Error opening {os.path.basename(file_path)}")

    def store_scheduled_task(self, seconds, task):
        """Store scheduled task in database with enhanced tracking"""
        try:
            db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
            
            # Calculate execution time
            execution_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Ensure table exists
            self.initialize_database()
            
            # Check for duplicate tasks that are still pending
            cursor.execute('''SELECT id FROM scheduled_tasks 
                             WHERE task = ? AND status = 'scheduled' AND completed = 0''', 
                             (task,))
            existing_task = cursor.fetchone()
            
            if existing_task:
                logging.warning(f"Duplicate task detected: '{task}'. Using existing task ID: {existing_task[0]}")
                conn.close()
                return existing_task[0]
            
            # Insert task with execution time
            cursor.execute('''INSERT INTO scheduled_tasks 
                             (task, seconds, scheduled_time, execution_time, status)
                             VALUES (?, ?, datetime('now'), ?, 'scheduled')''', 
                             (task, seconds, execution_time.strftime('%Y-%m-%d %H:%M:%S')))
            
            task_id = cursor.lastrowid
            conn.commit()
            conn.close()
            
            logging.info(f"Task '{task}' scheduled for execution at {execution_time}")
            return task_id
            
        except Exception as e:
            logging.error(f"Error storing scheduled task: {str(e)}")
            raise

    def initialize_database(self):
        """Initialize the task database with proper schema"""
        try:
            db_path = "C:\\Users\\HP\\Desktop\\Ai\\task.db"
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table with proper schema for task scheduling
            cursor.execute('''CREATE TABLE IF NOT EXISTS scheduled_tasks
                             (id INTEGER PRIMARY KEY AUTOINCREMENT,
                              task TEXT NOT NULL,
                              seconds INTEGER NOT NULL,
                              scheduled_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                              execution_time TIMESTAMP,
                              completed INTEGER DEFAULT 0,
                              status TEXT DEFAULT 'scheduled')''')
            
            conn.commit()
            conn.close()
            logging.info(f"Database initialized at {db_path}")
        except Exception as e:
            logging.error(f"Error initializing database: {str(e)}")
            raise

    def _execute_direct_command(self, command):
        """Execute a command directly, bypassing the scheduling logic.
        This ensures all commands are accessible to scheduled tasks."""
        try:
            # Track if this command has been executed to prevent duplicate execution
            command_execution_key = f"cmd_{hash(command)}_{int(time.time())}"
            
            # Check if we've already executed this exact command recently
            if hasattr(self, '_recent_commands'):
                current_time = time.time()
                # Clean up old commands (older than 5 seconds)
                self._recent_commands = {k: v for k, v in self._recent_commands.items() 
                                        if current_time - v < 5}
                
                # Check for duplicate commands
                for cmd_key, timestamp in self._recent_commands.items():
                    if cmd_key.startswith(f"cmd_{hash(command)}_") and current_time - timestamp < 3:
                        logging.warning(f"Preventing duplicate execution of command: '{command}' (executed {current_time - timestamp:.1f}s ago)")
                        return False
            else:
                self._recent_commands = {}
            
            # Mark this command as executed
            self._recent_commands[command_execution_key] = time.time()
            
            logging.info(f"Direct: '{command}'")
            
            # Check if this is a compound command (multiple commands separated by keywords)
            compound_commands = self._parse_compound_command(command)
            if len(compound_commands) > 1:
                logging.info(f"Detected compound command with {len(compound_commands)} parts: {compound_commands}")
                for cmd in compound_commands:
                    logging.info(f"Executing part of compound command: '{cmd}'")
                    self._execute_direct_command(cmd)
                    time.sleep(1)  # Small delay between commands
                return False
            
            # Web browsing commands
            if 'search youtube' in command:
                search_query = command.replace('search youtube', '').strip()
                if search_query:
                    search_url = f'https://www.youtube.com/results?search_query={urllib.parse.quote(search_query)}'
                    webbrowser.open(search_url)
                    self.speak(f"Searching YouTube for {search_query}")
                    return False
                else:
                    webbrowser.open('https://www.youtube.com')
                    self.speak("Opening YouTube")
                    return False
            
            if 'search for' in command or 'google search' in command or 'search google' in command:
                search_query = command
                for phrase in ['search for', 'google search', 'search google']:
                    search_query = search_query.replace(phrase, '').strip()
                
                if search_query:
                    search_url = f'https://www.google.com/search?q={urllib.parse.quote(search_query)}'
                    webbrowser.open(search_url)
                    self.speak(f"Searching Google for {search_query}")
                    return False
            
            # Handle "open" commands with improved fallback mechanism
            if command.startswith('open '):
                app_name = command.replace('open ', '', 1).strip().lower()
                
                # First, try direct execution for common applications
                success = False
                
                # Check for common applications with direct execution paths
                if app_name == 'notepad':
                    subprocess.Popen(['notepad.exe'])
                    success = True
                elif app_name == 'calculator':
                    subprocess.Popen(['calc.exe'])
                    success = True
                elif app_name == 'paint':
                    subprocess.Popen(['mspaint.exe'])
                    success = True
                elif app_name == 'cmd' or app_name == 'command prompt':
                    subprocess.Popen(['cmd.exe'])
                    success = True
                elif app_name == 'control panel':
                    subprocess.Popen(['control.exe'])
                    success = True
                elif app_name == 'google':
                    webbrowser.open('https://www.google.com')
                    success = True
                elif app_name == 'youtube':
                    webbrowser.open('https://www.youtube.com')
                    success = True
                elif app_name == 'wikipedia':
                    webbrowser.open('https://www.wikipedia.org')
                    success = True
                elif app_name == 'chrome' or app_name == 'google chrome':
                    chrome_paths = [
                        'chrome.exe',
                        'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
                        'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
                        os.path.expanduser('~') + '\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe'
                    ]
                    
                    for path in chrome_paths:
                        try:
                            subprocess.Popen([path])
                            success = True
                            logging.info(f"Successfully opened Chrome using path: {path}")
                            break
                        except Exception as chrome_error:
                            logging.debug(f"Failed to open Chrome with path {path}: {str(chrome_error)}")
                            continue
                
                # Try to open other browsers if requested
                elif app_name == 'firefox' or app_name == 'mozilla firefox':
                    firefox_paths = [
                        'firefox.exe',
                        'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
                        'C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe'
                    ]
                    
                    for path in firefox_paths:
                        try:
                            subprocess.Popen([path])
                            success = True
                            break
                        except:
                            continue
                
                elif app_name == 'edge' or app_name == 'microsoft edge':
                    edge_paths = [
                        'msedge.exe',
                        'C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe',
                        'C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe'
                    ]
                    
                    for path in edge_paths:
                        try:
                            subprocess.Popen([path])
                            success = True
                            break
                        except:
                            continue
                
                # Try to open Microsoft Office applications
                elif app_name in ['word', 'excel', 'powerpoint']:
                    success = self.open_system_app(app_name)
                
                # If direct execution succeeded
                if success:
                    self.speak(f"Opening {app_name}")
                    return False
                
                # If direct execution failed, try Windows search as fallback
                logging.info(f"Direct execution failed for '{app_name}', trying search and open")
                try:
                    # Use the improved search_and_click_first_result method
                    self.speak(f"Searching for {app_name}")
                    search_success = self.search_and_click_first_result(app_name)
                    return False
                except Exception as search_error:
                    logging.error(f"Error in fallback search for '{app_name}': {str(search_error)}")
                    self.speak(f"I had trouble opening {app_name}")
                    return False
            
            # System application commands - these are now handled by the generic "open" handler above
            # but keeping these for backward compatibility
            if 'open notepad' in command:
                subprocess.Popen(['notepad.exe'])
                self.speak("Opening Notepad")
                return False
                
            if 'open calculator' in command:
                subprocess.Popen(['calc.exe'])
                self.speak("Opening Calculator")
                return False
                
            if 'open paint' in command:
                subprocess.Popen(['mspaint.exe'])
                self.speak("Opening Paint")
                return False
                
            if 'open cmd' in command or 'open command prompt' in command:
                subprocess.Popen(['cmd.exe'])
                self.speak("Opening Command Prompt")
                return False
                
            if 'open control panel' in command:
                subprocess.Popen(['control.exe'])
                self.speak("Opening Control Panel")
                return False
            
            # Web commands - these are now handled by the generic "open" handler above
            # but keeping these for backward compatibility
            if 'open google' in command:
                webbrowser.open('https://www.google.com')
                self.speak("Opening Google")
                return False
                
            if 'open youtube' in command:
                webbrowser.open('https://www.youtube.com')
                self.speak("Opening YouTube")
                return False
                
            if 'open wikipedia' in command:
                webbrowser.open('https://www.wikipedia.org')
                self.speak("Opening Wikipedia")
                return False
                
            # Search and open first result
            if 'search and open' in command or 'find and open' in command:
                search_term = command
                for phrase in ['search and open', 'find and open']:
                    search_term = search_term.replace(phrase, '').strip()
                if search_term:
                    self.search_and_click_first_result(search_term)
                    return False
                else:
                    self.speak("Please specify what to search for")
                    return False

            # System commands
            if any(exit_cmd in command for exit_cmd in ['exit','you can leave','quit', 'goodbye', 'bye','see you later','you can','see you again']):
                self.speak("Thank you sir,see you soon")
                self.exit_assistant()
                return True
                
            # Typing commands
            if command.startswith('type '):
                self.type_and_enter(command)
                return False
                
            if command in ['stop typing', 'end typing', 'exit typing']:
                self.stop_typing()
                return False

            # Contact and WhatsApp commands
            if 'contact manager' in command or 'show contacts' in command:
                self.speak("Opening contact manager")
                self.root.after(0, self.show_contact_manager)
                return False
                
            # Tab commands
            if 'tab' in command:
                # Extract number from command
                tab_number = None
                if 'first' in command or '1st' in command or 'one' in command:
                    tab_number = 1
                elif 'second' in command or '2nd' in command or 'two' in command:
                    tab_number = 2
                elif 'third' in command or '3rd' in command or 'three' in command:
                    tab_number = 3
                elif 'fourth' in command or '4th' in command or 'four' in command:
                    tab_number = 4
                else:
                    # Try to extract number directly from command
                    numbers = [int(s) for s in command.split() if s.isdigit()]
                    if numbers:
                        tab_number = numbers[0]
                
                if tab_number is not None:
                    self.switch_tab(tab_number - 1)  # Convert to 0-based index
                    self.speak(f"Switched to tab {tab_number}")
                    return False
                    
            # Notes commands
            if 'open notes' in command:
                self.root.after(0, self.show_notes_window)
                return False
                
            # System health commands
            if 'check system health' in command or 'check system' in command or 'system health' in command:
                self.speak("Checking system health")
                self.check_system_health()
                return False
                
            # Search and open commands
            if any(phrase in command for phrase in ['search and open', 'find and open', 'search for and open']):
                search_term = command
                for phrase in ['search and open', 'find and open', 'search for and open']:
                    search_term = search_term.replace(phrase, '').strip()
                if search_term:
                    self.search_and_click_first_result(search_term)
                else:
                    self.speak("Please specify what to search for")
                return False
                
            # Data analysis commands
            if 'data analysis' in command:
                self.speak("Here You can analyse the Data")
                self.root.after(0, self.show_load_dataset_window)
                return False
                
            # Save notes commands
            if any(phrase in command for phrase in ['save notes in file', 'save note', 'save this note', 'save the note', 'save notes']):
                # Handle saving notes
                self.save_notes()
                return False
                
            # If no specific command matched, try to search and open
            if not command.startswith('search') and not any(word in command for word in ['open', 'check', 'save', 'type']):
                self.speak(f"Searching for {command}")
                self.search_and_click_first_result(command)
                return False
                
            # If still no match, try to search for the command as a last resort
            if command.startswith('open '):
                app_name = command.replace('open ', '', 1).strip()
                self.speak(f"I don't know how to open {app_name} directly. Searching for it...")
                self.search_and_click_first_result(app_name)
                return False
                
            # If absolutely no match, inform the user
            self.speak(f"I'm not sure how to handle the command: {command}")
            return False
            
        except Exception as e:
            logging.error(f"Error in direct command execution: {str(e)}")
            
            # Try to recover by searching for the command if it starts with "open"
            if command.startswith('open '):
                try:
                    app_name = command.replace('open ', '', 1).strip()
                    self.speak(f"I encountered an error. Trying to search for {app_name} instead.")
                    self.search_and_click_first_result(app_name)
                    return False
                except Exception as search_error:
                    logging.error(f"Error in recovery attempt: {str(search_error)}")
            
            self.speak("I encountered an error executing that command.")
            return False

    def _parse_compound_command(self, command):
        """Parse a compound command into individual commands"""
        logging.info(f"Parsing compound command: '{command}'")
        
        # Keywords that typically separate commands
        separators = ['open', 'search', 'check', 'find', 'save', 'type', 'show']
        
        # First, check if there are any obvious command separators like 'and', 'then'
        if ' and ' in command:
            return [cmd.strip() for cmd in command.split(' and ')]
            
        # Special case for common patterns
        if 'open notepad' in command and ('open google' in command or 'search' in command):
            parts = []
            if 'open notepad' in command:
                parts.append('open notepad')
                command = command.replace('open notepad', '', 1).strip()
            
            if 'open google' in command:
                parts.append('open google')
                command = command.replace('open google', '', 1).strip()
            
            if 'search youtube' in command:
                search_query = command.replace('search youtube', '', 1).strip()
                if search_query:
                    parts.append(f"search youtube {search_query}")
                else:
                    parts.append("search youtube")
            elif 'search' in command:
                search_query = command.replace('search', '', 1).strip()
                if search_query:
                    parts.append(f"search for {search_query}")
                else:
                    parts.append("search")
            elif command.strip():
                parts.append(command.strip())
                
            if parts:
                return parts
        
        # Next, look for command keywords that might indicate the start of a new command
        result = []
        
        # Add the first command
        result.append(command)
        
        # Look for keywords that might indicate the start of a new command
        for separator in separators:
            # Skip the first occurrence as it's likely part of the first command
            start_pos = command.find(separator)
            if start_pos == -1:
                continue
                
            # Look for subsequent occurrences
            pos = command.find(f" {separator} ", start_pos + 1)
            while pos != -1:
                # Split the command at this position
                first_part = command[:pos].strip()
                second_part = command[pos+1:].strip()
                
                # If we found a valid split point
                if first_part and second_part and len(first_part.split()) >= 2:
                    result = [first_part, second_part]
                    break
                    
                # Look for the next occurrence
                pos = command.find(f" {separator} ", pos + 1)
        
        # If we couldn't find a good split point, try a more aggressive approach
        if len(result) == 1 and len(command.split()) > 4:
            words = command.split()
            commands = []
            current_command = []
            
            for word in words:
                if word in separators and current_command:
                    # If we encounter a separator and already have words in the current command,
                    # finish the current command and start a new one
                    commands.append(' '.join(current_command))
                    current_command = [word]
                else:
                    current_command.append(word)
            
            # Add the last command if it exists
            if current_command:
                commands.append(' '.join(current_command))
            
            # Only use this result if we found multiple commands
            if len(commands) > 1:
                result = commands
        
        # If we still couldn't find a good split point, try an even more aggressive approach
        if len(result) == 1 and len(command.split()) > 6:
            words = command.split()
            for i in range(2, len(words) - 1):
                if words[i] in separators:
                    first_part = ' '.join(words[:i])
                    second_part = ' '.join(words[i:])
                    if first_part and second_part:
                        result = [first_part, second_part]
                        break
        
        logging.info(f"Parsed into: {result}")
        return result
        
    def search_and_click_first_result(self, search_term):
        """Search for a term and click the first result"""
        try:
            self.speak(f"Searching for {search_term}")
            
            # Open Windows search
            pyautogui.hotkey('win', 's')
            time.sleep(1)
            
            # Type the search term
            pyautogui.typewrite(search_term, interval=0.05)
            time.sleep(1.5)  # Wait for search results
            
            # Press Enter to open the first result
            pyautogui.press('enter')
            
            self.speak(f"Opening {search_term}")
            return True
        except Exception as e:
            logging.error(f"Error in search_and_click_first_result: {str(e)}")
            self.speak(f"I couldn't find {search_term}")
            return False

    def show_translation_comparison(self, target_language=None):
        """Show sentence-by-sentence translation comparison for highlighted text"""
        try:
            # 1. Get highlighted text
            pyautogui.hotkey('ctrl', 'c')
            time.sleep(0.1)
            
            try:
                highlighted_text = self.root.clipboard_get().strip()
            except:
                self.speak("No text was highlighted")
                return

            if not highlighted_text:
                self.speak("Please highlight some text first")
                return

            # Create translation window with Tron Legacy theme
            translation_window = tk.Toplevel(self.root)
            translation_window.title("Translation Comparison - TRON Interface")
            translation_window.geometry("1800x800")
            translation_window.configure(bg='#000000')

            # Add glowing border effect
            border_frame = tk.Frame(
                translation_window,
                bg='#000000',
                highlightbackground='#15f4ee',
                highlightthickness=3
            )
            border_frame.pack(fill='both', expand=True, padx=6, pady=6)

            # Create main frame with Tron styling
            main_frame = tk.Frame(border_frame, bg='#000000')
            main_frame.pack(fill='both', expand=True, padx=25, pady=25)

            # Add title with Tron styling
            title_frame = tk.Frame(main_frame, bg='#000000')
            title_frame.pack(fill='x', pady=(0, 25))

            title_label = tk.Label(
                title_frame,
                text="TRANSLATION MATRIX",
                font=("Share Tech Mono", 28, "bold"),
                bg='#000000',
                fg='#15f4ee'
            )
            title_label.pack(side='left')

            # Language selection frame
            lang_frame = tk.Frame(main_frame, bg='#000000')
            lang_frame.pack(fill='x', pady=(0, 25))

            # Source language
            tk.Label(
                lang_frame,
                text="FROM:",
                font=("Share Tech Mono", 14),
                bg='#000000',
                fg='#FF410D'
            ).pack(side='left', padx=(0, 15))

            source_lang = ttk.Combobox(
                lang_frame,
                values=sorted(self.language_dict.keys()),
                width=25,
                font=("Share Tech Mono", 12),
                state='readonly'
            )
            source_lang.set("English")
            source_lang.pack(side='left', padx=(0, 25))

            # Target language
            tk.Label(
                lang_frame,
                text="TO:",
                font=("Share Tech Mono", 14),
                bg='#000000',
                fg='#FF410D'
            ).pack(side='left', padx=(0, 15))

            target_lang = ttk.Combobox(
                lang_frame,
                values=sorted(self.language_dict.keys()),
                width=25,
                font=("Share Tech Mono", 12),
                state='readonly'
            )
            target_lang.set("Spanish" if not target_language else target_language)
            target_lang.pack(side='left')

            # Create scrollable frame
            scroll_frame = tk.Frame(main_frame, bg='#000000')
            scroll_frame.pack(fill='both', expand=True, pady=(0, 25))

            # Create canvas for scrolling
            canvas = tk.Canvas(
                scroll_frame,
                bg='#000000',
                highlightthickness=0
            )
            scrollbar = ttk.Scrollbar(scroll_frame, orient="vertical", command=canvas.yview)
            
            # Create frame for content
            content_frame = tk.Frame(canvas, bg='#000000')
            
            # Configure canvas
            canvas.configure(yscrollcommand=scrollbar.set)
            canvas.bind('<Configure>', lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
            canvas_window = canvas.create_window((0, 0), window=content_frame, anchor='nw')

            # Update content frame width when canvas is resized
            def update_content_width(event):
                canvas.itemconfig(canvas_window, width=event.width)
            canvas.bind('<Configure>', update_content_width)

            # Pack scrolling components
            scrollbar.pack(side="right", fill="y")
            canvas.pack(side="left", fill="both", expand=True)

            def translate_text():
                try:
                    # Disable translate button
                    translate_btn.config(state='disabled', text="TRANSLATING...")
                    
                    # Get language codes
                    source_code = self.language_dict[source_lang.get()]
                    target_code = self.language_dict[target_lang.get()]

                    # Clear previous translations
                    for widget in content_frame.winfo_children():
                        widget.destroy()

                    # Create loading frame
                    loading_frame = tk.Frame(content_frame, bg='#000000')
                    loading_frame.pack(pady=20)
                    
                    loading_label = tk.Label(
                        loading_frame,
                        text="TRANSLATING TEXT...",
                        font=("Share Tech Mono", 14),
                        bg='#000000',
                        fg='#15f4ee'
                    )
                    loading_label.pack()

                    progress_bar = ttk.Progressbar(
                        loading_frame,
                        mode='indeterminate',
                        length=400
                    )
                    progress_bar.pack(pady=10)
                    progress_bar.start(10)

                    def process_translation():
                        try:
                            # 2. Translate the entire text at once
                            translator = GoogleTranslator(source=source_code, target=target_code)
                            full_translation = translator.translate(highlighted_text)

                            # 3. Split original and translated text into sentences
                            original_sentences = [s.strip() for s in re.split('[.!?]+', highlighted_text) if s.strip()]
                            translated_sentences = [s.strip() for s in re.split('[.!?]+', full_translation) if s.strip()]

                            # Ensure equal number of sentences for display
                            min_sentences = min(len(original_sentences), len(translated_sentences))
                            original_sentences = original_sentences[:min_sentences]
                            translated_sentences = translated_sentences[:min_sentences]

                            # Update UI on main thread
                            def update_ui():
                                try:
                                    # Remove loading indicators
                                    loading_frame.destroy()
                                    
                                    # Display translations
                                    for i, (original, translated) in enumerate(zip(original_sentences, translated_sentences)):
                                        # Create pair frame
                                        pair_frame = tk.Frame(content_frame, bg='#000000')
                                        pair_frame.pack(fill='x', pady=10, padx=15)
                                        
                                        # Original text
                                        original_frame = tk.Frame(pair_frame, bg='#000000')
                                        original_frame.pack(side='left', fill='both', expand=True, padx=5)
                                        
                                        tk.Label(
                                            original_frame,
                                            text=f"ORIGINAL ({source_lang.get()})",
                                            font=("Share Tech Mono", 12),
                                            bg='#000000',
                                            fg='#15f4ee'
                                        ).pack(anchor='w', pady=(0, 5))
                                        
                                        original_text = tk.Text(
                                            original_frame,
                                            height=4,
                                            width=50,
                                            bg='#0D1B2A',
                                            fg='#15f4ee',
                                            font=("Share Tech Mono", 11),
                                            wrap=tk.WORD,
                                            padx=10,
                                            pady=5
                                        )
                                        original_text.pack(fill='both')
                                        original_text.insert('1.0', original)
                                        original_text.config(state='disabled')
                                        
                                        # Translated text
                                        translated_frame = tk.Frame(pair_frame, bg='#000000')
                                        translated_frame.pack(side='right', fill='both', expand=True, padx=5)
                                        
                                        tk.Label(
                                            translated_frame,
                                            text=f"TRANSLATED ({target_lang.get()})",
                                            font=("Share Tech Mono", 12),
                                            bg='#000000',
                                            fg='#FF410D'
                                        ).pack(anchor='w', pady=(0, 5))
                                        
                                        translated_text = tk.Text(
                                            translated_frame,
                                            height=4,
                                            width=50,
                                            bg='#0D1B2A',
                                            fg='#FF410D',
                                            font=("Share Tech Mono", 11),
                                            wrap=tk.WORD,
                                            padx=10,
                                            pady=5
                                        )
                                        translated_text.pack(fill='both')
                                        translated_text.insert('1.0', translated)
                                        translated_text.config(state='disabled')

                                        # Add copy buttons
                                        buttons_frame = tk.Frame(pair_frame, bg='#000000')
                                        buttons_frame.pack(fill='x', pady=5)

                                        def create_copy_button(text_widget, label):
                                            def copy_text():
                                                translation_window.clipboard_clear()
                                                translation_window.clipboard_append(text_widget.get("1.0", tk.END).strip())
                                                
                                                # Show copy notification
                                                notification = tk.Toplevel(translation_window)
                                                notification.overrideredirect(True)
                                                notification.configure(bg='#15f4ee')
                                                
                                                tk.Label(
                                                    notification,
                                                    text=f"{label} COPIED",
                                                    font=("Share Tech Mono", 11),
                                                    bg='#15f4ee',
                                                    fg='#000000',
                                                    padx=20,
                                                    pady=10
                                                ).pack()
                                                
                                                # Position notification
                                                x = translation_window.winfo_x() + translation_window.winfo_width() - 200
                                                y = translation_window.winfo_y() + 50
                                                notification.geometry(f"+{x}+{y}")
                                                
                                                # Destroy after 1.5 seconds
                                                notification.after(1500, notification.destroy)

                                            return tk.Button(
                                                buttons_frame,
                                                text=f"COPY {label}",
                                                command=copy_text,
                                                font=("Share Tech Mono", 10, "bold"),
                                                bg='#0D1B2A',
                                                fg='#15f4ee',
                                                activebackground='#15f4ee',
                                                activeforeground='#0D1B2A',
                                                relief='flat',
                                                padx=15,
                                                pady=5,
                                                cursor='hand2'
                                            )

                                        copy_original = create_copy_button(original_text, "ORIGINAL")
                                        copy_translated = create_copy_button(translated_text, "TRANSLATION")
                                        
                                        copy_original.pack(side='left', padx=5)
                                        copy_translated.pack(side='right', padx=5)

                                        # Add separator
                                        if i < min_sentences - 1:
                                            separator = tk.Frame(content_frame, height=2, bg='#15f4ee')
                                            separator.pack(fill='x', pady=10)
                                    
                                    # Re-enable translate button
                                    translate_btn.config(state='normal', text="TRANSLATE")
                                    
                                except Exception as e:
                                    messagebox.showerror("Error", f"Error updating UI: {str(e)}", parent=translation_window)
                            
                            translation_window.after(0, update_ui)
                            
                        except Exception as e:
                            translation_window.after(0, lambda: messagebox.showerror(
                                "Translation Error", 
                                f"Translation failed: {str(e)}", 
                                parent=translation_window
                            ))
                            translation_window.after(0, lambda: translate_btn.config(
                                state='normal', 
                                text="TRANSLATE"
                            ))

                    # Run translation in background
                    threading.Thread(target=process_translation, daemon=True).start()
                    
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to start translation: {str(e)}", parent=translation_window)
                    translate_btn.config(state='normal', text="TRANSLATE")

            # Add translate button
            translate_btn = tk.Button(
                main_frame,
                text="TRANSLATE",
                command=translate_text,
                font=("Share Tech Mono", 14, "bold"),
                bg='#0D1B2A',
                fg='#15f4ee',
                activebackground='#15f4ee',
                activeforeground='#0D1B2A',
                relief='flat',
                padx=25,
                pady=10,
                cursor='hand2'
            )
            translate_btn.pack(pady=20)

            # Center window
            translation_window.update_idletasks()
            width = translation_window.winfo_width()
            height = translation_window.winfo_height()
            x = (translation_window.winfo_screenwidth() // 2) - (width // 2)
            y = (translation_window.winfo_screenheight() // 2) - (height // 2)
            translation_window.geometry(f'{width}x{height}+{x}+{y}')

            # Make window modal
            translation_window.transient(self.root)
            translation_window.grab_set()

            # Auto-translate if target language specified
            if target_language:
                translation_window.after(500, translate_text)

        except Exception as e:
            self.handle_errors(e, "Translation window error")
            self.speak("Sorry, I encountered an error with the translation window")

    # Add this dictionary to your class if you don't have it already
    language_dict = {
        "English": "en",
        "Spanish": "es",
        "French": "fr",
        "German": "de",
        "Italian": "it",
        "Portuguese": "pt",
        "Russian": "ru",
        "Japanese": "ja",
        "Korean": "ko",
        "Chinese": "zh",
        "Arabic": "ar",
        "Hindi": "hi",
        "Bengali": "bn",
        "Tamil": "ta",
        "Telugu": "te",
        "Kannada": "kn",
        "Malayalam": "ml",
        "Marathi": "mr",
        "Gujarati": "gu",
        "Urdu": "ur"
    }
    def switch_tab(self, index):
        """Switch to specified tab using Alt+Tab"""
        try:
            # Press Alt+Tab once to activate window switcher
            pyautogui.keyDown('alt')
            
            # If we need to go forward
            if index > 0:
                for _ in range(index):
                    pyautogui.press('tab')
                    time.sleep(0.1)  # Small delay between tabs
                        # Release Alt to select the window
            pyautogui.keyUp('alt')
            
        except Exception as e:
            self.handle_errors(e, "Error switching tabs")
            self.speak("Sorry, I couldn't switch tabs") 
    def is_valid_website(self, website):
        """Check if the website is valid for auto-login."""
        # List of known websites for auto-login
        known_websites = ["google", "facebook", "twitter", "linkedin", "github"]
        return any(known in website for known in known_websites)
    def show_program_output(self):
        """Show programming output in Tron Legacy themed window with syntax highlighting"""
        try:
            # Get highlighted text
            pyautogui.hotkey('ctrl','a')
            pyautogui.hotkey('ctrl', 'c')
            time.sleep(0.1)
            
            try:
                highlighted_text = self.root.clipboard_get().strip()
            except:
                self.speak("No text was highlighted")
                return

            if not highlighted_text:
                self.speak("Please highlight some text first")
                return

            # Create output window with Tron Legacy theme
            output_window = tk.Toplevel(self.root)
            output_window.title("Program Output - TRON Interface")
            output_window.geometry("800x600")
            output_window.configure(bg='#000000')

            # Add glowing border effect
            border_frame = tk.Frame(
                output_window,
                bg='#000000',
                highlightbackground='#15f4ee',
                highlightthickness=2
            )
            border_frame.pack(fill='both', expand=True, padx=4, pady=4)

            # Create main frame with Tron styling
            main_frame = tk.Frame(border_frame, bg='#000000')
            main_frame.pack(fill='both', expand=True, padx=20, pady=20)

            # Add title with Tron styling
            title_frame = tk.Frame(main_frame, bg='#000000')
            title_frame.pack(fill='x', pady=(0, 20))

            title_label = tk.Label(
                title_frame,
                text="PROGRAM SOLUTION",
                font=("Share Tech Mono", 18, "bold"),
                bg='#000000',
                fg='#15f4ee'
            )
            title_label.pack(side='left')

            # Create loading frame
            loading_frame = tk.Frame(main_frame, bg='#000000')
            loading_frame.pack(fill='x', pady=20)

            # Add loading label with Tron styling
            loading_label = tk.Label(
                loading_frame,
                text="INITIALIZING CODE GENERATION",
                font=("Share Tech Mono", 14),
                bg='#000000',
                fg='#FF410D'
            )
            loading_label.pack()

            # Progress bar with Tron styling
            style = ttk.Style()
            style.configure(
                'Tron.Horizontal.TProgressbar',
                troughcolor='#000B19',
                background='#15f4ee',
                thickness=4,
                width=15,
                arrowsize=15
            )

            progress_bar = ttk.Progressbar(
                loading_frame,
                mode='indeterminate',
                length=300,
                style='Tron.Horizontal.TProgressbar'
            )
            progress_bar.pack(pady=10)

            # Add animated dots
            dots_label = tk.Label(
                loading_frame,
                text="",
                font=("Share Tech Mono", 14),
                bg='#000000',
                fg='#FF410D'
            )
            dots_label.pack()

            # Create text widget with syntax highlighting (initially hidden)
            output_text = scrolledtext.ScrolledText(
                main_frame,
                wrap=tk.NONE,
                font=("JetBrains Mono", 12),
                bg='#000B19',
                fg='#15f4ee',
                insertbackground='#15f4ee',
                height=20,
                relief='flat'
            )

            # Configure syntax highlighting tags
            output_text.tag_configure('keyword', foreground='#FF410D')
            output_text.tag_configure('string', foreground='#95FF00')
            output_text.tag_configure('comment', foreground='#7A7A7A')
            output_text.tag_configure('function', foreground='#15f4ee')
            output_text.tag_configure('number', foreground='#FFB700')
            output_text.tag_configure('operator', foreground='#FF410D')
            output_text.tag_configure('builtin', foreground='#FF410D')

            def on_window_close():
                try:
                    # Stop all animations and cleanup
                    output_window.is_generating = False
                    if hasattr(dots_label, 'animation_id'):
                        output_window.after_cancel(dots_label.animation_id)
                    if progress_bar.winfo_exists():
                        progress_bar.stop()
                    output_window.destroy()
                except Exception as e:
                    print(f"Error during cleanup: {e}")
                    output_window.destroy()

            def animate_dots():
                try:
                    if not hasattr(output_window, 'is_generating') or not output_window.is_generating:
                        return
                    if not dots_label.winfo_exists():
                        return
                        
                    current_text = dots_label.cget("text")
                    if current_text == "....":
                        dots_label.config(text="")
                    else:
                        dots_label.config(text=current_text + ".")
                        
                    # Only schedule next animation if still generating and label exists
                    if output_window.is_generating and dots_label.winfo_exists():
                        dots_label.animation_id = output_window.after(500, animate_dots)
                except tk.TclError:
                    # Widget was destroyed, stop animation
                    return
                except Exception as e:
                    print(f"Animation error: {str(e)}")
                    return

            def update_loading_status(status):
                loading_label.config(text=status)
                output_window.update_idletasks()

            def generate_code():
                try:
                    output_window.is_generating = True
                    progress_bar.start(10)
                    animate_dots()

                    import google.generativeai as genai
                    genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
                    model = genai.GenerativeModel('gemini-2.0-flash')
                    
                    update_loading_status("ANALYZING REQUIREMENTS")
                    time.sleep(1)
                    
                    update_loading_status("GENERATING CODE SOLUTION")
                    prompt = f"""Create a complete, working program for: {highlighted_text}
                    Guidelines:
                    - Provide only the code without any markdown formatting
                    - Include necessary imports
                    - Use clear variable names
                    - Add brief inline comments
                    - Make it production-ready
                    - Return raw code only, no explanations or decorations
                    - Explanation should be short and sweet, don't take more lines to explain
                    """
                    
                    response = model.generate_content(prompt)
                    program = response.text.strip()
                    program = program.replace('```python', '').replace('```', '').strip()
                    
                    update_loading_status("APPLYING SYNTAX HIGHLIGHTING")
                    time.sleep(0.5)

                    # Clean up loading elements
                    output_window.is_generating = False
                    progress_bar.stop()
                    loading_frame.destroy()

                    # Show text widget
                    output_text.pack(fill='both', expand=True, pady=(0, 10))
                    # Add these lists after the output_text.pack() line and before the for loop
                    # Show text widget
                    output_text.pack(fill='both', expand=True, pady=(0, 10))
                    
                    # Define syntax highlighting tokens
                    keywords = ['def', 'class', 'import', 'from', 'return', 'if', 'else', 'elif',
                              'try', 'except', 'finally', 'for', 'while', 'in', 'and', 'or',
                              'not', 'is', 'None', 'True', 'False', 'with', 'as', 'break',
                              'continue', 'pass', 'raise', 'yield', 'async', 'await']
                              
                    builtins = ['print', 'len', 'range', 'str', 'int', 'float', 'list', 'dict',
                               'set', 'tuple', 'sum', 'min', 'max', 'sorted', 'enumerate',
                               'zip', 'map', 'filter', 'any', 'all', 'round', 'abs', 'open']
                                        
                    
                    for line in program.split('\n'):
                    
                        if not line.strip():
                            output_text.insert('end', '\n')
                            continue
                            
                        # Handle comments
                        if line.strip().startswith('#'):
                            output_text.insert('end', line + '\n', 'comment')
                            continue
                        
                        # Process code line
                        current_pos = 0
                        line_length = len(line)
                        
                        while current_pos < line_length:
                            # Handle whitespace
                            if line[current_pos].isspace():
                                output_text.insert('end', line[current_pos])
                                current_pos += 1
                                continue
                            
                            # Find next token
                            if line[current_pos] in '"\'':  # String
                                quote = line[current_pos]
                                end_pos = line.find(quote, current_pos + 1)
                                if end_pos == -1:
                                    end_pos = line_length
                                output_text.insert('end', line[current_pos:end_pos + 1], 'string')
                                current_pos = end_pos + 1
                            elif line[current_pos:].startswith('#'):  # Comment
                                output_text.insert('end', line[current_pos:], 'comment')
                                current_pos = line_length
                            else:  # Code token
                                # Find end of token
                                end_pos = current_pos
                                while end_pos < line_length and (line[end_pos].isalnum() or line[end_pos] == '_'):
                                    end_pos += 1
                                token = line[current_pos:end_pos]
                                
                                if token in keywords:
                                    output_text.insert('end', token, 'keyword')
                                elif token in builtins:
                                    output_text.insert('end', token, 'builtin')
                                elif token.isdigit():
                                    output_text.insert('end', token, 'number')
                                elif token and token[0].isupper():
                                    output_text.insert('end', token, 'class')
                                else:
                                    output_text.insert('end', token)
                                
                                if end_pos == current_pos:  # Handle operators and other symbols
                                    output_text.insert('end', line[current_pos])
                                    end_pos += 1
                                current_pos = end_pos
                        
                        output_text.insert('end', '\n')
                    
                except Exception as e:
                    output_window.is_generating = False
                    progress_bar.stop()
                    loading_frame.destroy()
                    output_text.pack(fill='both', expand=True, pady=(0, 10))
                    output_text.insert('1.0', f"Error generating program: {str(e)}")

            # Add buttons frame with Tron styling
            buttons_frame = tk.Frame(main_frame, bg='#000000')
            buttons_frame.pack(fill='x', pady=(10, 0))

            def create_glowing_button(parent, text, command, color='#15f4ee'):
                frame = tk.Frame(
                    parent,
                    bg='#000000',
                    highlightbackground=color,
                    highlightthickness=1
                )
                
                btn = tk.Button(
                    frame,
                    text=text,
                    command=command,
                    bg='#000B19',
                    fg=color,
                    font=("Share Tech Mono", 11),
                    relief='flat',
                    cursor='hand2',
                    activebackground='#000B19',
                    activeforeground='#FFFFFF',
                    bd=0,
                    padx=20,
                    pady=5
                )
                btn.pack(padx=1, pady=1)
                
                def on_enter(e):
                    frame.config(highlightbackground='#FFFFFF')
                    btn.config(fg='#FFFFFF')
                def on_leave(e):
                    frame.config(highlightbackground=color)
                    btn.config(fg=color)
                    
                btn.bind('<Enter>', on_enter)
                btn.bind('<Leave>', on_leave)
                return frame

            # Copy button
            create_glowing_button(
                buttons_frame,
                "COPY CODE",
                lambda: self.root.clipboard_append(output_text.get("1.0", tk.END))
            ).pack(side='left', padx=5)

            # Close button
            create_glowing_button(
                buttons_frame,
                "CLOSE",
                on_window_close,
                color='#FF410D'
            ).pack(side='right', padx=5)

            # Add window protocol handler
            output_window.protocol("WM_DELETE_WINDOW", on_window_close)

            # Start code generation in a separate thread
            threading.Thread(target=generate_code, daemon=True).start()

            # Make window modal
            output_window.transient(self.root)
            output_window.grab_set()

        except Exception as e:
            self.handle_errors(e, "Error showing program output")
            self.speak("Sorry, I encountered an error generating the program")
    def process_command(self, command):
        """Process voice commands"""
        try:
            command = command.lower().strip()
            
            # Add the new database analysis command
            if 'analyse database' in command or 'analyze database' in command:
                self.speak("Opening database analysis window")
                self.root.after(0, self.analyze_database)
                return False
            
            if any(cmd in command for cmd in ['open google']):
                            webbrowser.open('https://www.google.com')
                            self.speak("Opening Google")
                            return False
                        # Add new image identification commands
                            
            if 'search for' in command:
                search_query = command.replace('search for', '').strip()
                if search_query:
                    search_url = f'https://www.google.com/search?q={urllib.parse.quote(search_query)}'
                    webbrowser.open(search_url)
                    self.speak(f"Searching Google for {search_query}")
                    return False
                
            if 'open youtube' in command:
                webbrowser.open('https://www.youtube.com')
                self.speak("Opening YouTube")
                return False
                
            if 'open wikipedia' in command:
                webbrowser.open('https://www.wikipedia.org')
                self.speak("Opening Wikipedia")
                return False

            # Programming commands
            if any(cmd in command for cmd in ['programming window','programming assistant','programming']):
                self.speak("Opening the programming assistant")
                try:
                    import google.generativeai as genai
                    self.root.after(0, self.show_programming_window)
                except ImportError:
                    self.speak("Please install the required package google-generativeai first")
                    logging.error("google-generativeai package not installed")
                return False
        
            # System commands
            if any(exit_cmd in command for exit_cmd in ['exit','you can leave','quit', 'goodbye', 'bye','see you later','you can','see you again']):
                self.speak("Thank you sir,see you soon")
                self.exit_assistant()
                return True

            # System info commands
            if 'brightness' in command:
                self.control_brightness(command)
                return False
            
            if 'volume' in command:
                self.control_volume(command)
                return False
            
            if 'battery' in command:
                self.get_battery_info()
                return False
            
            if 'storage' in command or 'disk space' in command:
                self.get_storage_info()
                return False
            
            if any(word in command for word in ['time', 'date', 'day']):
                self.get_time_date()
                return False

            # Typing commands
            if command.startswith('type '):
                self.type_and_enter(command)
                return False
                
            if command in ['stop typing', 'end typing', 'exit typing']:
                self.stop_typing()
                return False

            # Contact and WhatsApp commands
            if 'contact manager' in command or 'show contacts' in command:
                self.speak("Opening contact manager")
                self.root.after(0, self.show_contact_manager)
                return False
            elif 'tab' in command:
            # Extract number from command
                tab_number = None
                if 'first' in command or '1st' in command or 'one' in command:
                    tab_number = 1
                elif 'second' in command or '2nd' in command or 'two' in command:
                    tab_number = 2
                elif 'third' in command or '3rd' in command or 'three' in command:
                    tab_number = 3
                elif 'fourth' in command or '4th' in command or 'four' in command:
                    tab_number = 4
                else:
                    # Try to extract number directly from command
                    numbers = [int(s) for s in command.split() if s.isdigit()]
                    if numbers:
                        tab_number = numbers[0]
                
                if tab_number is not None:
                    self.switch_tab(tab_number - 1)  # Convert to 0-based index
                    self.speak(f"Switched to tab {tab_number}")
                    return False
            

            

            
            if 'send a message to' in command:
                contact_name = command.replace('send a message to', '').strip()
                if contact_name:
                    self.whatsapp_interaction('message', contact_name)
                    return True
                
            if 'video call' in command:
                contact_name = command.replace('video call', '').strip()
                if contact_name:
                    self.whatsapp_interaction('video', contact_name)
                    return True
                    
            if 'whatsapp call' in command:
                contact_name = command.replace('whatsapp call', '').strip()
                if contact_name:
                    self.whatsapp_interaction('call', contact_name)
                    return True
            elif "auto login" in command:
                website = command.replace("auto login", "").strip()
                if website:
                    # Validate the website before proceeding
                    if self.is_valid_website(website):
                        self.auto_login(website)
                    else:
                        self.speak(f"I cannot log into {website}. Please specify a valid website.")
                else:
                    self.speak("Please specify the website for auto login.")
                return False
                
            # Show password manager command
            elif "password manager" in command:
                self.show_password_manager()
                return False
            elif command in ['delete text','delete the text']:
                pyautogui.hotkey('delete')
                return False
            is_scheduled_task = False
            if command.startswith("__scheduled__:"):
                is_scheduled_task = True
                command = command.replace("__scheduled__:", "", 1).strip()
                logging.info(f"Processing scheduled task command: '{command}'")
            
            # For scheduled tasks, we'll use a direct command execution approach
            # This ensures all commands are accessible to scheduled tasks
            if is_scheduled_task:
                return self._execute_direct_command(command)
            elif not is_scheduled_task and 'schedule' in command and ('task' in command or 'reminder' in command or '' in command):
                max_retries = 3
                retry_count = 0
                
                while retry_count < max_retries:
                    self.speak("How long until the tasks should start?")
                    duration = self.take_command()
                    
                    if duration and duration.lower() != 'none':
                        seconds = self.parse_duration(duration)
                        if seconds > 0:
                            self.speak("What tasks would you like to schedule?.")
                            tasks = self.take_command()
                            if tasks and tasks.lower() != 'none':
                                # Split tasks by commas and clean them
                                task_list = [t.strip() for t in tasks.split(',') if t.strip()]
                                if task_list:
                                    # Join tasks with commas and pass to scheduler
                                    self.show_task_scheduler(preset_time=seconds, preset_tasks=','.join(task_list))
                                    return False
                            # If no valid tasks were provided, open scheduler with just the time
                            self.show_task_scheduler(preset_time=seconds)
                            return False
                        else:
                            retry_count += 1
                            if retry_count < max_retries:
                                self.speak("I couldn't understand the time duration. Please try saying it like '5 minutes' or '2 hours' or '30 seconds'.")
                            else:
                                self.speak("I'm still having trouble understanding the time. Would you like to enter it manually in the scheduler window?")
                                response = self.take_command()
                                if any(word in response.lower() for word in ['yes', 'yeah', 'sure', 'okay']):
                                    self.show_task_scheduler()
                                else:
                                    self.speak("Task scheduling cancelled.")
                                return False
                    else:
                        retry_count += 1
                        if retry_count < max_retries:
                            self.speak("I didn't catch that. Please try again with the duration.")
                        else:
                            self.speak("I'm having trouble understanding. Would you like to open the scheduler window to enter the time manually?")
                            response = self.take_command()
                            if any(word in response.lower() for word in ['yes', 'yeah', 'sure', 'okay']):
                                self.show_task_scheduler()
                            else:
                                self.speak("Task scheduling cancelled.")
                            return False
                return False
            elif 'new text file' in command:
                pyautogui.hotkey('ctrl', 'n')
                self.speak("Done")
                return False
            elif 'new text window' in command:
                pyautogui.hotkey('ctrl', 'shift', 'n')
                self.speak("Done")
                return False
            elif 'open file' in command:
                pyautogui.hotkey('ctrl', 'o')
                self.speak("Done")
                return False
            elif 'data analysis' in command:
                self.speak("Here You can analyse the Data")
                self.root.after(0, self.show_data_analysis_window)
                return False

            elif 'open folder' in command:
                pyautogui.hotkey('ctrl', 'shift', 'o')
                self.speak("Done")
                return False
            elif 'translate' in command:
                # Extract target language if specified
                target_lang = None
                for lang_name in self.language_dict.keys():
                    if f"to {lang_name.lower()}" in command:
                        target_lang = lang_name
                        break
                
                self.show_translation_comparison(target_lang)
                return False
        

            elif 'undo' in command:
                pyautogui.hotkey('ctrl', 'z')
                self.speak("Done")
                return False
            elif 'select all' in command:
                pyautogui.hotkey('ctrl', 'a')
                self.speak("Done")
                return False
            elif any(phrase in command for phrase in ['program for highlighted', 'create a program']):
                self.show_program_output()
                return False 
            elif 'run window' in command:
                pyautogui.hotkey('win', 'r')
                self.speak("Done")
                return False
            elif 'copy' in command:
                pyautogui.hotkey('ctrl', 'c')
                self.speak("Done")
                return False
            elif 'copy all' in command:
                pyautogui.hotkey('ctrl', 'a')
                pyautogui.hotkey('ctrl', 'c')
                self.speak("Done")
                return False
            elif 'paste' in command:
                pyautogui.hotkey('ctrl', 'v')
                self.speak("Done")
                return False
            elif 'cut' in command:
                pyautogui.hotkey('ctrl', 'x')
                self.speak("Done")
                return False
            elif 'find' in command:
                pyautogui.hotkey('ctrl', 'f')
                self.speak("Done")
                return False
            elif 'close window' in command:
                pyautogui.hotkey('alt', 'f4')
                self.speak("Done")
                return False
            elif 'enter' in command:
                pyautogui.hotkey('enter')
                self.speak("Done")
                return False
            elif command in ['check properties','check property','check property of']:
                pyautogui.hotkey('alt', 'enter')
                self.speak("Done")
                return False
            elif any(phrase in command for phrase in ['maximize all', 'maximize the all window', 'maximize all windows', 'maximize window', 'maximize the window', 'restore all window', 'restore window', 'restore all']):
                pyautogui.hotkey('win', 'shift', 'm')  # Windows shortcut to restore/maximize all windows
                self.speak("All windows maximized")
                return False
            elif any(phrase in command for phrase in ['save notes in file','save note', 'save this note', 'save the note', 'save notes']):
                try:
                    # Base directory for notes
                    notes_dir = r"C:\Users\HP\\Desktop\Notes"
                    
                    # Get current date and time
                    now = datetime.datetime.now()
                    week_num = now.isocalendar()[1]
                    weekday = now.strftime('%A')
                    
                    # Create directory structure
                    week_dir = os.path.join(notes_dir, f"Week_{week_num}")
                    day_dir = os.path.join(week_dir, weekday)
                    
                    # Create directories if they don't exist
                    os.makedirs(day_dir, exist_ok=True)
                    
                    # Save active notepad content
                    active_window = pyautogui.getActiveWindow()
                    if "Notepad" in str(active_window.title):
                        # Get notepad content
                        # Select all text
                        pyautogui.hotkey('ctrl', 'a')
                        time.sleep(0.2)
                        # Copy text
                        pyautogui.hotkey('ctrl', 'c')
                        time.sleep(0.2)
                        
                        # Get text from clipboard
                        import win32clipboard
                        win32clipboard.OpenClipboard()
                        try:
                            text = win32clipboard.GetClipboardData()
                        except:
                            text = ""
                        finally:
                            win32clipboard.CloseClipboard()

                        if text.strip():
                            # Generate filename using Gemini
                            filename = self.generate_filename_from_content(text)
                            if not filename:
                                # Fallback to timestamp if analysis fails
                                timestamp = now.strftime('%Y%m%d_%H%M%S')
                                filename = f"note_{timestamp}.txt"
                            
                            # Ensure filename is valid
                            filename = self.sanitize_filename(filename)
                            filepath = os.path.join(day_dir, filename)
                            
                            # Save to file
                            with open(filepath, 'w', encoding='utf-8') as f:
                                f.write(text)
                            
                            self.speak(f"Notes saved as {filename} in {weekday} folder for Week {week_num}")
                        else:
                            self.speak("No content to save")
                    else:
                        self.speak("Please make sure Notepad is active")
                        
                except Exception as e:
                    logging.error(f"Error saving notes: {str(e)}")
                    self.speak("Sorry, I couldn't save the notes")
                return False


            elif 'switch window' in command:
                pyautogui.hotkey('alt', 'tab')
                self.speak("Done")
                return False
            elif 'minimise all' in command or 'minimise the all window' in command or 'minimise the window' in command or 'minimise window' in command:
                pyautogui.hotkey('win', 'm')
                self.speak("Done")
                return False
            
            elif 'task manager' in command:
                pyautogui.hotkey('ctrl', 'shift', 'esc')
                self.speak("Done")
                return False
            elif 'lock screen' in command:
                pyautogui.hotkey('win', 'l')
                self.speak("Done")
                return False

            elif 'search youtube' in command or 'youtube search' in command or 'youtube' in command:
                search_query = command.replace('search youtube', '').replace('youtube search', '').replace('youtube', '').strip()
                if search_query:
                    url = f"https://www.youtube.com/results?search_query={urllib.parse.quote(search_query)}"
                    webbrowser.open(url)
                    self.speak(f"Searching YouTube for {search_query}")
                else:
                    self.speak("Please specify what to search on YouTube")
                return False
            elif any(cmd in command for cmd in ['chatbot', 'gemini chat','gemini','chat box','anish','anish chat']):
                self.speak("Opening ANIS chat")
                self.root.after(0, self.show_chat_window)
                return False
            elif 'translate window' in command or 'translator' in command:
                self.speak("Opening translator")
                self.root.after(0, self.show_translator_window)
                return False

            elif 'make notes' in command or 'summary' in command:
                self.speak("Opening summarizer window")
                self.root.after(0, self.show_summarizer_window)
                return False

            elif 'show email' in command or 'show mail' in command or 'send email' in command or 'send mail' in command or 'send a mail' in command or'send a email' in command or 'send an email' in command:
                self.root.after(0, self.show_email_window)
                return False

            elif 'open notes' in command:
                self.root.after(0, self.show_notes_window)
                return False

            elif 'check system health' in command or 'check system' in command or 'check system status' in command or 'check system information' in command or 'check system details' in command or 'check system status' in command or 'check system information' in command or 'check system details' in command:
                self.speak("Checking system health")
                self.check_system_health()
                return False
            elif any(phrase in command for phrase in ['search and open', 'find and open', 'search for and open']):
                search_term = command
                for phrase in ['search and open', 'find and open', 'search for and open']:
                    search_term = search_term.replace(phrase, '').strip()
                if search_term:
                    self.search_and_click_first_result(search_term)
                else:
                    self.speak("Please specify what to search for")
                return False
            
            elif any(phrase in command for phrase in ['save notes in file', 'save note', 'save this note', 'save the note', 'save notes']):
                try:
                    # Base directory for notes
                    notes_dir = r"C:\Users\HP\Desktop\Ai\Notes"
                    
                    # Get current date and time
                    now = datetime.datetime.now()
                    week_num = now.isocalendar()[1]
                    weekday = now.strftime('%A')
                    
                    # Create directory structure
                    week_dir = os.path.join(notes_dir, f"Week_{week_num}")
                    day_dir = os.path.join(week_dir, weekday)
                    
                    # Create directories if they don't exist
                    os.makedirs(day_dir, exist_ok=True)
                    
                    # Generate filename with timestamp
                    timestamp = now.strftime('%Y%m%d_%H%M%S')
                    filename = f"note_{timestamp}.txt"
                    filepath = os.path.join(day_dir, filename)
                    
                    # Save active notepad content
                    active_window = pyautogui.getActiveWindow()
                    if "Notepad" in active_window.title:
                        # Select all text
                        pyautogui.hotkey('ctrl', 'a')
                        time.sleep(0.1)
                        # Copy text
                        pyautogui.hotkey('ctrl', 'c')
                        time.sleep(0.1)
                        
                        # Get text from clipboard
                        text = self.window.clipboard_get()
                        
                        # Save to file
                        with open(filepath, 'w', encoding='utf-8') as f:
                            f.write(text)
                        
                        self.speak(f"Notes saved in {weekday} folder for Week {week_num}")
                    else:
                        self.speak("Please make sure Notepad is active")
                        
                except Exception as e:
                    logging.error(f"Error saving notes: {str(e)}")
                    self.speak("Sorry, I couldn't save the notes")
                return False

        # ... rest of your existing commands ...
            # Check for system app commands
            elif 'open' in command:
                # First try system apps
                if self.open_system_app(command):
                    return False
                    
                # If system app not found, try desktop search
                search_term = command.replace('open', '').strip()
                if search_term:
                    self.search_and_click_first_result(search_term)
                return False
            elif 'take screenshot' in command:
                    self.speak("Taking screenshot")
                    self.take_screenshot()
                    return False
    

            elif any(phrase in command for phrase in ['save highlighted text','save the highlights','save the hightlight','save selection', 'save selected text', 'save highlight', 'save the highlighted words']):
                try:
                    # Base directory for important notes
                    notes_dir = r"C:\Users\HP\Desktop\Ai\Important Notes"
                    
                    # Create base directory if it doesn't exist
                    if not os.path.exists(notes_dir):
                        os.makedirs(notes_dir)
                    
                    # Get current date and time
                    now = datetime.datetime.now()
                    week_num = now.isocalendar()[1]
                    weekday = now.strftime('%A')
                    
                    # Create directory structure
                    week_dir = os.path.join(notes_dir, f"Week_{week_num}")
                    day_dir = os.path.join(week_dir, weekday)
                    os.makedirs(day_dir, exist_ok=True)

                    # Copy selected text using keyboard shortcut
                    pyautogui.hotkey('ctrl', 'c')
                    time.sleep(0.5)  # Wait for clipboard to update

                    # Get text from clipboard using tkinter
                    try:
                        selected_text = self.root.clipboard_get()
                    except:
                        self.speak("No text was selected")
                        return False

                    if not selected_text or selected_text.strip() == "":
                        self.speak("Please select some text first")
                        return False

                    # Generate filename using Gemini
                    try:
                        import google.generativeai as genai
                        genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
                        model = genai.GenerativeModel('gemini-2.0-flash')
                        
                        prompt = f"Generate a short, descriptive filename (2-3 words) for this text: {selected_text[:200]}"
                        response = model.generate_content(prompt)
                        suggested_name = response.text.strip()
                        
                        timestamp = now.strftime('%Y%m%d_%H%M%S')
                        filename = f"{suggested_name}_{timestamp}.txt"
                    except Exception as e:
                        logging.error(f"Error generating filename: {str(e)}")
                        timestamp = now.strftime('%Y%m%d_%H%M%S')
                        filename = f"selected_text_{timestamp}.txt"

                    # Clean filename
                    filename = self.sanitize_filename(filename)
                    filepath = os.path.join(day_dir, filename)

                    # Save the file
                    with open(filepath, 'w', encoding='utf-8') as f:
                        f.write(f"Date: {now.strftime('%Y-%m-%d %H:%M:%S')}\n")
                        f.write("-" * 50 + "\n\n")
                        f.write(selected_text)

                    # Verify file was saved
                    if os.path.exists(filepath):
                        self.speak(f"Selected text saved successfully in {weekday} folder")
                        logging.info(f"Saved selected text to: {filepath}")
                    else:
                        self.speak("Failed to save the text")

                except Exception as e:
                    logging.error(f"Error saving selected text: {str(e)}")
                    self.speak("Sorry, I couldn't save the selected text")
                return False

                
            
            elif 'google search' in command or 'search google' in command:
                    # Extract search query if provided
                    search_query = command.replace('google search', '').replace('search google', '').replace('google', '').strip()
                    if search_query:

                        self.speak(f"Searching Google for {search_query}")
                        url = f"https://www.google.com/search?q={urllib.parse.quote(search_query)}"
                        webbrowser.open(url)
                    else:
                        self.speak("Opening Google")
                        webbrowser.open("https://www.google.com")
                    return False
            # If no specific command matched, use Gemini for chat response
            try:
                
                self.type_and_enter("Processing your request...")
                custom_prompt = self.load_prompt('voice_commands')
                if custom_prompt:
                    prompt = f"""GuideLines: {custom_prompt}Guidelines:
                - answer should be in two lines for any query
                - Use simple language
                - Avoid special characters or formatting
                - Use proper punctuation
                - Keep responses brief and direct
                -your name is A N I S AI integrated with Operation System With Help Of Gemini and under Developing by 
                Samiulla from 26 August 2024 don't  tell this in beginning of your response you should tell only when someone ask you name
                - No emojis or symbols
                - answer in a friendly manner
                - answer like a human
                - answer in a way that is easy to understand
                - answer in a way that is not too formal
                - answer in a way that is not too technical
                - if need techinical answer in techincal terms
                - answer should be short like 2 lines and concise
                - avoid geographical deep terms
                - try to answer in 2 lines simple and short
                - some of the time you can answer in a funny way
                \n\nUser Query: {command}"""
                else:
                    prompt = f"""Please provide a clear and concise response to: {command}
                    Guidelines:
                - Use simple language
                - Avoid special characters or formatting
                - Use proper punctuation
                - Keep responses brief and direct
                -your name is A N I S AI integrated with Operation System With Help Of Gemini and under Developing by 
                Samiulla from 26 August 2024 don't  tell this in beginning of your response you should tell only when someone ask you name
                - No emojis or symbols
                - answer in a friendly manner
                - answer like a human
                - answer in a way that is easy to understand
                - answer in a way that is not too formal
                - answer in a way that is not too technical
                - if need techinical answer in techincal terms
                - answer should be short like 2 lines and concise
                - avoid geographical deep terms
                - try to answer in 2 lines simple and short
                - some of the time you can answer in a funny way
                """
                
                # Construct a prompt that encourages clear, simple responses
                # Get response from Gemini
                response = self.chat.send_message(prompt)
                response_text = response.text.strip()
                
                # Clean up the response
                response_text = response_text.replace('*', '').replace('#', '').replace('`', '')
                
                # Stop typing animation
                self.stop_typing()
                
                # Speak and display the response
                self.speak(response_text)
                self.log_interaction(command, response_text)
                return False
                
            except Exception as e:
                self.handle_errors(e, "Error getting Gemini response")
                self.speak("I'm having trouble understanding that right now. Could you please try again?")
                return False
                
        except Exception as e:
            self.handle_errors(e, "Error processing command")
            self.speak("Sorry, I encountered an error processing that command")
            return False
            
           
            

        
    def toggle_listening(self):
        """Toggle between play and pause states"""
        try:
            if not self.start_button._listening:
                # Start listening
                self.start_button._listening = True
                self.start_button.config(text="◼")  # Change to pause symbol
                self.listening_thread = threading.Thread(target=self.listen_for_commands)
                self.listening_thread.daemon = True
                self.listening_thread.start()
                self.status_label.config(text="● Listening", fg='#4CAF50')
            else:
                # Pause listening
                self.start_button._listening = False
                self.start_button.config(text="▶")  # Back to play symbol
                self.status_label.config(text="Not Listening", fg='#f44336')
        except Exception as e:
            logging.error(f"Error toggling listening state: {str(e)}")
            self.speak("Sorry, I encountered an error with the voice recognition")

    def start_listening(self):
        """Start the listening process"""
        try:
            self.start_button._listening = True
            self.start_button.config(text="◼")  # Square stop symbol
            self.start_color_transition(self.start_button, '#27ae60')
            self.start_button.master.config(highlightbackground='#27ae60')
            self.listening_thread = threading.Thread(target=self.listen_for_commands, daemon=True)
            self.listening_thread.start()
            self.status_label.config(text="● Listening", fg='#4CAF50')
        except Exception as e:
            logging.error(f"Error in start_listening: {str(e)}")
            self.status_label.config(text="● Not Listening", fg='#ff4d4d')

    def listen_for_commands(self):
        """Continuously listen for commands until paused or exit command is given"""
        try:
            while self.start_button._listening:
                command = self.take_command()
                if command != 'none':
                    result = self.process_command(command)
                    if result is True:  # Exit command given
                        self.start_button.config(text="▶")
                        self.start_button._listening = False
                        self.status_label.config(text="● Not Listening", fg='#ff4d4d')
                        break
                    
                    # Update UI to show we're still listening (if not paused)
                    if self.start_button._listening:
                        self.start_button.config(text="◼")
                        self.status_label.config(text="● Listening", fg='#4CAF50')
        except Exception as e:
            logging.error(f"Error in listen_for_commands: {str(e)}")
            self.speak("I encountered an error. Please try again.")
            # Reset state
            self.start_button.config(text="▶")
            self.start_button._listening = False
            self.status_label.config(text="● Not Listening", fg='#ff4d4d')


    def exit_assistant(self):
        """Safely exit the voice assistant"""
        try:
            # Stop any ongoing processes
            self.start_button._listening = False
            
            # Cancel any scheduled updates
            if hasattr(self, '_after_id'):
                self.root.after_cancel(self._after_id)
            
            # Clean up resources
            if hasattr(self, 'engine'):
                self.engine.stop()
            
            if hasattr(self, 'wave_vis'):
                self.wave_vis.cleanup()
            
            # Destroy the root window if it still exists
            if hasattr(self, 'root') and self.root.winfo_exists():
                self.root.quit()
                self.root.destroy()
                
        except Exception as e:
            logging.error(f"Error during exit: {str(e)}")
            # Force exit if needed
            sys.exit(0)

   
    
    def check_system_health(self):
        try:
            # CPU Usage
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # Memory Usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            
            # Disk Usage
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent
            
            health_report = (
                f"System Health Report:\n"
                f"CPU Usage: {cpu_percent}%\n"
                f"Memory Usage: {memory_percent}%\n"
                f"Disk Usage: {disk_percent}%"
            )
            
            self.speak(health_report)
            
            # Log the health report
            logging.info(health_report)
            
            # Alert if any metrics are too high
            if cpu_percent > 90 or memory_percent > 90 or disk_percent > 90:
                self.speak("Warning: System resources are running very high!")
                
        except Exception as e:
            self.speak("Unable to check system health")
            logging.error(f"System health check error: {str(e)}")
    def get_notepad_content(self):
        """Get content from active notepad window"""
        try:
            # Save current clipboard content
            original_clipboard = self.window.clipboard_get()
            
            # Select and copy text from notepad
            pyautogui.hotkey('ctrl', 'a')
            time.sleep(0.1)
            pyautogui.hotkey('ctrl', 'c')
            time.sleep(0.1)
            
            # Get text from clipboard
            text = self.window.clipboard_get()
            
            # Restore original clipboard content
            self.window.clipboard_clear()
            self.window.clipboard_append(original_clipboard)
            
            return text.strip()
        except Exception as e:
            logging.error(f"Error getting notepad content: {str(e)}")
            return None

    def generate_filename_from_content(self, content):
        """Generate appropriate filename by analyzing content using Gemini"""
        try:
            import google.generativeai as genai
            
            # Configure Gemini
            genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            model = genai.GenerativeModel('gemini-2.0-flash')
            
            # Prepare prompt
            prompt = f"""Analyze this text content and generate a short, descriptive filename (1 words, separated by underscores).
            The filename should reflect the main topic or purpose of the content.
            Only return the filename, no other text.
            
            Content:
            {content[:500]}...
            """
            
            # Get response from Gemini
            response = model.generate_content(prompt)
            filename = response.text.strip()
            
            # Add timestamp and extension
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            return f"{filename}_{timestamp}.txt"
            
        except Exception as e:
            logging.error(f"Error generating filename: {str(e)}")
            return None
    def show_email_window(self):
        """Open the email window"""
        try:
            EmailWindow(self.root)
        except Exception as e:
            self.speak("Sorry, I encountered an error while opening the email window")
            logging.error(f"Email window error: {str(e)}")
    
    def sanitize_filename(self, filename):
        """Ensure filename is valid by removing/replacing invalid characters"""
        import re
        
        # First, replace newlines and tabs with spaces
        filename = filename.replace('\n', ' ').replace('\t', ' ')
        
        # Replace multiple spaces with single underscore
        filename = re.sub(r'\s+', '_', filename.strip())
        
        # Remove or replace invalid characters
        # Windows reserved characters and other problematic ones
        invalid_chars = r'[<>:"/\\|?*\'\[\]{}()!@#$%^&+=;,.]'
        filename = re.sub(invalid_chars, '_', filename)
        
        # Replace multiple underscores with single underscore
        filename = re.sub(r'_+', '_', filename)
        
        # Remove leading/trailing underscores
        filename = filename.strip('_')
        
        # Convert to lowercase for consistency
        filename = filename.lower()
        
        # If filename is empty after cleaning, use a default
        if not filename:
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            return f"note_{timestamp}"
        
        # Ensure filename is not too long
        max_length = 255
        if len(filename) > max_length:
            name, ext = os.path.splitext(filename)
            filename = name[:max_length-len(ext)] + ext
        
        return filename
    
    def show_translator_window(self):
        """Open the translator window"""
        try:
            translator = TranslatorWindow(self.root)
            # Wait for translator window to be destroyed
            self.root.wait_window(translator.window)
            # After translator closes, just update the UI and continue with existing listening thread
            self.start_button.config(text="◼", bg='#27ae60')
            self.status_label.config(text="Listening...")
            
        except Exception as e:
            self.speak("Sorry, I encountered an error with the translator")
            logging.error(f"Translator window error: {str(e)}")
            # Update UI to show we're still listening
            self.start_button.config(text="", bg='#27ae60')
            self.status_label.config(text="Listening...")
    def take_screenshot(self):
        try:
            # Create screenshots directory if it doesn't exist
            screenshot_dir = "screenshots"
            if not os.path.exists(screenshot_dir):
                os.makedirs(screenshot_dir)

            # Take screenshot
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            screenshot_path = os.path.join(screenshot_dir, f"screenshot_{timestamp}.png")
            screenshot = ImageGrab.grab()
            screenshot.save(screenshot_path)
            
            self.speak(f"Screenshot saved")
            return screenshot_path
        except Exception as e:
            self.speak("Failed to take screenshot")
            logging.error(f"Screenshot error: {str(e)}")
            return None
    
    def handle_keyboard_shortcuts(self):
        try:
            # Register keyboard shortcuts
            keyboard.add_hotkey('ctrl+shift+a', self.start_listening)
            keyboard.add_hotkey('ctrl+shift+x', self.exit_assistant)
            keyboard.add_hotkey('ctrl+shift+s', self.take_screenshot)
            
            # Start listening for keyboard events
            keyboard.wait()
            
        except Exception as e:
            logging.error(f"Keyboard shortcut error: {str(e)}")

    def log_interaction(self, user_input, assistant_response):
        try:
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = (
                f"Time: {timestamp}\n"
                f"User: {user_input}\n"
                f"Assistant: {assistant_response}\n"
                f"{'-'*50}\n"
            )
            
            with open("interaction_log.txt", "a", encoding="utf-8") as log_file:
                log_file.write(log_entry)
                
        except Exception as e:
            logging.error(f"Logging error: {str(e)}")

    def handle_errors(self, error, context=""):
        """Generic error handler for the assistant"""
        error_message = f"Error in {context}: {str(error)}"
        logging.error(error_message)
        user_message = "I encountered an error. Please try again."
        self.speak(user_message)
        
        # Update status
        self.update_status(False)
        
        # Log the interaction
        self.log_interaction(context, user_message)

    def process_text_command(self, text_input):
        """Process text commands without voice input"""
        try:
            if text_input:
                self.output_text.config(state=NORMAL)
                self.output_text.insert(END, f"Text Input: {text_input}\n")
                self.output_text.config(state=DISABLED)
                self.output_text.see(END)
                
                return self.process_command(text_input.lower())
            return False
        except Exception as e:
            self.handle_errors(e, "text command processing")
            return False

    def setup_keyboard_shortcuts(self):
        """Setup keyboard shortcuts for the assistant"""
        try:
            # Start keyboard listener thread
            keyboard_thread = threading.Thread(
                target=self.handle_keyboard_shortcuts,
                daemon=True
            )
            keyboard_thread.start()
        except Exception as e:
            self.handle_errors(e, "keyboard shortcut setup")


    def speak(self, text, emotion=None):
        try:
            if hasattr(self, 'wave_vis') and self.wave_vis.is_active:
                self.wave_vis.speaking_animation()
            
            # Use the new styled text output
            self.insert_with_timestamp(f"A.N.I.S: {text}", "assistant_msg")
            
            engine.say(text)
            engine.runAndWait()
            
            if hasattr(self, 'wave_vis') and self.wave_vis.is_active:
                self.wave_vis.stop_listening_animation()
        except Exception as e:
            logging.error(f"Error in speak method: {str(e)}")

    def take_command(self):
        r = sr.Recognizer()
        with sr.Microphone() as source:
            try:
                if hasattr(self, 'wave_vis') and self.wave_vis.is_active:
                    self.wave_vis.start_listening_animation()
                self.status_label.config(text="Listening...")
                self.root.update()
                
                # Adjust for ambient noise
                r.adjust_for_ambient_noise(source, duration=1)
                r.dynamic_energy_threshold = True
                r.pause_threshold = 0.8
                r.non_speaking_duration = 0.4
                r.phrase_threshold = 0.3
                
                audio = r.listen(source, timeout=10 ,phrase_time_limit=8)
                
                self.status_label.config(text="Recognizing...")
                self.root.update()
                
                query = r.recognize_google(audio, language='en-in')
                
                # Use the new styled text output
                self.insert_with_timestamp(f"You: {query}", "user_msg")
                
                return query.lower()
                
            except sr.WaitTimeoutError:
                return "none"
            except sr.UnknownValueError:
                return "none"
            except sr.RequestError:
                self.speak("Sorry, there was an error with the speech recognition service")
                return "none"
            except Exception as e:
                logging.error(f"Error in speech recognition: {str(e)}")
                return "none"
            finally:
                if hasattr(self, 'wave_vis') and self.wave_vis.is_active:
                    self.wave_vis.stop_listening_animation()
                self.status_label.config(text="Not Listening")

    def start_color_transition(self, widget, target_color, steps=10):
        """Start smooth color transition animation"""
        if not hasattr(self, 'color_transitions'):
            self.color_transitions = {}
            
        # Stop any existing transition for this widget
        if widget in self.color_transitions:
            self.root.after_cancel(self.color_transitions[widget])
            
        current_color = widget.cget('bg')
        
        def interpolate_color(start_color, end_color, step, total_steps):
            """Interpolate between two colors"""
            start_rgb = [int(start_color[i:i+2], 16) for i in (1, 3, 5)]
            end_rgb = [int(end_color[i:i+2], 16) for i in (1, 3, 5)]
            
            current_rgb = [
                int(start_rgb[i] + (end_rgb[i] - start_rgb[i]) * step / total_steps)
                for i in range(3)
            ]
            
            return f'#{current_rgb[0]:02x}{current_rgb[1]:02x}{current_rgb[2]:02x}'
            
        def animate_step(step=0):
            if step <= steps:
                color = interpolate_color(current_color, target_color, step, steps)
                widget.config(bg=color)
                self.color_transitions[widget] = self.root.after(
                    20,  # 20ms per step for smooth animation
                    lambda: animate_step(step + 1)
                )
            else:
                self.color_transitions.pop(widget, None)
                
        animate_step()

    def update_system_stats(self):
        """Update system statistics"""
        try:
            # Update CPU usage
            cpu_percent = psutil.cpu_percent(interval=0.1)
            self.cpu_label.config(text=f"CPU: {cpu_percent}%")
            
            # Update memory usage
            memory = psutil.virtual_memory()
            self.memory_label.config(text=f"RAM: {memory.percent}%")
            
            # Schedule next update
            self.root.after(1000, self.update_system_stats)
        except Exception as e:
            logging.error(f"Error updating system stats: {str(e)}")
            
    def show_settings(self):
        """Show settings window"""
        settings_window = tk.Toplevel(self.root)
        settings_window.title("Settings")
        settings_window.geometry("600x700")
        settings_window.configure(bg=self.themes[self.current_theme]["bg"])
        
        # Make window modal
        settings_window.transient(self.root)
        settings_window.grab_set()
        
        # Style for the notebook and tabs
        style = ttk.Style()
        
        # Configure notebook style
        style.configure(
            "TNotebook",
            background='#0a0a1f',
            borderwidth=0,
            tabmargins=[2, 5, 2, 0]
        )
        
        # Configure tab style
        style.configure(
            "TNotebook.Tab",
            padding=[15, 5],
            background='#0a0a1f',
            foreground='#000000',
            font=("Segoe UI", 11, "bold"),
            borderwidth=0,
            focuscolor='#4361ee'
        )
        
        # Configure tab states
        style.map("TNotebook.Tab",
            background=[
                ("selected", '#4361ee'),
                ("active", '#2a2a4a'),
                ("!selected", '#0a0a1f')
            ],
            foreground=[
                ("selected", "#000000"),
                ("active", "#000000"),
                ("!selected", "#000000")
            ]
        )
        
        # Create notebook
        notebook = ttk.Notebook(settings_window)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Theme Tab
        theme_frame = Frame(notebook, bg=self.themes[self.current_theme]["bg"], padx=20, pady=20)
        
        Label(
            theme_frame,
            text="Theme Selection",
            font=("Segoe UI", 16, "bold"),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["accent"]
        ).pack(anchor='w', pady=(0, 20))
        
        # Theme selection with improved visibility
        theme_var = tk.StringVar(value=self.current_theme)
        for theme_name in self.themes.keys():
            # Create container frame for each radio button
            button_container = Frame(
                theme_frame,
                bg=self.themes[self.current_theme]["bg"],
                padx=10,
                pady=5
            )
            button_container.pack(fill='x', pady=5)
            
            # Create modern radio button
            theme_button = tk.Radiobutton(
                button_container,
                text=theme_name,
                variable=theme_var,
                value=theme_name,
                command=lambda t=theme_name: self.change_theme(t),
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["fg"],
                selectcolor=self.themes[self.current_theme]["accent"],
                activebackground=self.themes[self.current_theme]["bg"],
                activeforeground=self.themes[self.current_theme]["accent"],
                font=("Segoe UI", 12),
                cursor="hand2",
                relief="flat",
                bd=0,
                highlightthickness=0,
                padx=15,
                pady=8,
                indicatoron=0
            )
            theme_button.pack(fill='x')
            
            # Add hover effect
            def on_enter(e, button=theme_button):
                if button.cget('state') != 'selected':
                    button.configure(
                        bg=self.themes[self.current_theme]["highlight"],
                        fg=self.themes[self.current_theme]["accent"]
                    )

            def on_leave(e, button=theme_button):
                if button.cget('state') != 'selected':
                    button.configure(
                        bg=self.themes[self.current_theme]["bg"],
                        fg=self.themes[self.current_theme]["fg"]
                    )

            theme_button.bind('<Enter>', on_enter)
            theme_button.bind('<Leave>', on_leave)
            
            # Update appearance if this is the selected theme
            if theme_name == self.current_theme:
                theme_button.configure(
                    bg=self.themes[self.current_theme]["accent"],
                    fg="#ffffff"
                )

        # Volume Tab
        volume_frame = Frame(notebook, bg=self.themes[self.current_theme]["bg"], padx=20, pady=20)
        
        Label(
            volume_frame,
            text="Volume Settings",
            font=("Segoe UI", 16, "bold"),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["accent"]
        ).pack(anchor='w', pady=(0, 20))
        
        Label(
            volume_frame,
            text="Assistant Voice Volume",
            font=("Segoe UI", 12),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(anchor='w', pady=(0, 10))
        
        # Volume control with improved visibility
        volume_control_frame = Frame(volume_frame, bg=self.themes[self.current_theme]["bg"])
        volume_control_frame.pack(fill='x', pady=10)
        
        # Configure volume scale style
        style.configure(
            "Custom.Horizontal.TScale",
            background=self.themes[self.current_theme]["bg"],
            troughcolor=self.themes[self.current_theme]["accent"],
            bordercolor=self.themes[self.current_theme]["accent"]
        )
        
        self.volume_scale = ttk.Scale(
            volume_control_frame,
            from_=0,
            to=100,
            orient='horizontal',
            value=engine.getProperty('volume') * 100,
            command=self.change_volume,
            style="Custom.Horizontal.TScale"
        )
        self.volume_scale.pack(fill='x', pady=10)
        
        # Volume labels with better contrast
        volume_labels_frame = Frame(volume_control_frame, bg=self.themes[self.current_theme]["bg"])
        volume_labels_frame.pack(fill='x')
        
        Label(
            volume_labels_frame,
            text="0%",
            font=("Segoe UI", 11),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(side='left')
        
        Label(
            volume_labels_frame,
            text="100%",
            font=("Segoe UI", 11),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["fg"]
        ).pack(side='right')

        # Help Tab
        help_frame = Frame(notebook, bg=self.themes[self.current_theme]["bg"], padx=20, pady=20)
        
        Label(
            help_frame,
            text="Available Commands",
            font=("Segoe UI", 16, "bold"),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["accent"]
        ).pack(anchor='w', pady=(0, 20))
        
        # Create help text with custom scrollbar
        help_frame_container = Frame(help_frame, bg=self.themes[self.current_theme]["bg"])
        help_frame_container.pack(fill='both', expand=True)
        
        help_text = Text(
            help_frame_container,
            wrap=WORD,
            height=25,
            bg=self.themes[self.current_theme]["text_bg"],
            fg=self.themes[self.current_theme]["fg"],
            font=("Segoe UI", 11),
            selectbackground=self.themes[self.current_theme]["accent"],
            selectforeground="#ffffff",
            insertbackground=self.themes[self.current_theme]["accent"]
        )
        help_text.pack(side='left', fill='both', expand=True)
        
        # Create and style the scrollbar
        scrollbar = ttk.Scrollbar(
            help_frame_container,
            orient='vertical',
            command=help_text.yview
        )
        scrollbar.pack(side='right', fill='y')
        
        # Configure the text widget to use the scrollbar
        help_text['yscrollcommand'] = scrollbar.set
        
        # Add help content
        help_content = """
    🎯 Voice Commands:

    🔍 Search & Browse:
    • "wikipedia [topic]" - Search Wikipedia
    • "search youtube [query]" - Search on YouTube
    • "google search [query]" OR "search google [query]" - Search on Google
    • "open [website]" - Open websites (youtube/google/whatsapp/facebook/twitter/instagram)

    🖱️ Screen Interaction:
    • "click on [element]" - Click on screen elements
    • "type [text]" - Type at cursor position
    • "stop typing" - End typing mode

    🎮 System Controls:
    • "check system health" - View system status
    • "take screenshot" - Capture screen
    • "create backup" - Backup system data

    🎵 Media Controls:
    • "play music" - Play random music
    • "play [song name]" - Play specific song

    🌍 Translator:
    • "translate" - Open translator
    • "translate [text]" - Translate text

    y

    ⌨️ Keyboard Shortcuts:
    • Ctrl+Shift+A - Start listening
    • Ctrl+Shift+X - Exit assistant
    • Ctrl+Shift+S - Take screenshot
    • Ctrl+Shift+H - Check system health
    • Ctrl+Shift+B - Create backup

    ❌ Exit Commands:
    • "exit" or "quit" or "goodbye"
    • "you can leave"

    💡 Tips:
    • Click the play button (▶) to start
    • Click stop button (◼) to pause
    • Watch the wave animation for voice activity
    • Monitor system stats in top bar
    """
        help_text.insert('1.0', help_content)
        help_text.config(state='disabled')

        # Create main prompts frame with scrollbar
        prompts_main_frame = Frame(notebook, bg=self.themes[self.current_theme]["bg"])
        prompts_main_frame.pack(fill='both', expand=True)
        
        # Create canvas and scrollbar
        canvas = Canvas(
            prompts_main_frame,
            bg=self.themes[self.current_theme]["bg"],
            highlightthickness=0
        )
        scrollbar = ttk.Scrollbar(
            prompts_main_frame,
            orient="vertical",
            command=canvas.yview
        )
        
        # Create scrollable frame
        prompts_frame = Frame(
            canvas,
            bg=self.themes[self.current_theme]["bg"],
            padx=20,
            pady=20
        )
        
        # Configure canvas
        prompts_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=prompts_frame, anchor="nw", width=canvas.winfo_width())
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Configure canvas resize
        def on_canvas_configure(event):
            canvas.itemconfig(canvas_frame_id, width=event.width)
        canvas_frame_id = canvas.create_window((0, 0), window=prompts_frame, anchor="nw")
        canvas.bind('<Configure>', on_canvas_configure)
        
        # Add mousewheel scrolling
        def on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        canvas.bind_all("<MouseWheel>", on_mousewheel)
        
        # Add prompt settings section
        Label(
            prompts_frame,
            text="Custom Agent Prompt Guidelines",
            font=("Segoe UI", 16, "bold"),
            bg=self.themes[self.current_theme]["bg"],
            fg=self.themes[self.current_theme]["accent"]
        ).pack(anchor='w', pady=(0, 20))
        
        # Create sections for different prompt types
        prompt_sections = {
            'voice_commands': "Voice Commands Prompt",
            'chat_window': "Chat Window Prompt",
            'article_mode': "Article Mode Prompt",
            'programming': "Programming Assistant Prompt",
            'header_analysis': "Data Headers Analysis Prompt",
            'full_analysis': "Full Dataset Analysis Prompt",
            
        }
        
        for key, title in prompt_sections.items():
            section_frame = Frame(prompts_frame, bg=self.themes[self.current_theme]["bg"])
            section_frame.pack(fill='x', pady=10)
            
            Label(
                section_frame,
                text=title,
                font=("Segoe UI", 12),
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["fg"]
            ).pack(anchor='w')
            
            # Add placeholder text label
            placeholder_text = {
                'voice_commands': "{command} - Voice command, {context} - Command context",
                'chat_window': "{message} - User message, {history} - Chat history",
                'article_mode': "{text} - Article content, {mode} - Analysis mode",
                'programming': "{code} - Code snippet, {language} - Programming language",
                'header_analysis': "{headers} - Dataset column names",
                'full_analysis': "{data_summary} - Dataset statistics",
                
            }
            
            Label(
                section_frame,
                text=placeholder_text[key],
                font=("Segoe UI", 9, "italic"),
                bg=self.themes[self.current_theme]["bg"],
                fg=self.themes[self.current_theme]["secondary"]
            ).pack(anchor='w', pady=(0, 5))
            
            text_widget = Text(
                section_frame,
                height=4,
                wrap=WORD,
                bg=self.themes[self.current_theme]["text_bg"],
                fg=self.themes[self.current_theme]["fg"],
                font=("Segoe UI", 10)
            )
            text_widget.pack(fill='x', pady=5)
            
            # Load existing prompt if available
            current_prompt = self.load_prompt(key)
            if current_prompt:
                text_widget.insert('1.0', current_prompt)
            else:
                # Default prompts
                default_prompts = {
                    'voice_commands': """Process this voice command and determine the appropriate action.
    Consider the context and user preferences.

    Command: {command}
    Context: {context}""",
                    'chat_window': """You are a helpful AI assistant. Respond to the user's message
    while maintaining context of the conversation.

    Message: {message}
    History: {history}""",
                    'article_mode': """Analyze this article and provide key insights.
    Include main points and relevant details.

    Text: {text}
    Mode: {mode}""",
                    'programming': """Review this code and provide:
    1. Code analysis
    2. Suggestions for improvement
    3. Best practices
    4. Potential issues

    Code: {code}
    Language: {language}""",
                    'header_analysis': """Analyze these dataset headers and provide:
    1. Brief explanation of each header
    2. Potential relationships between headers
    3. What insights could be derived

    Headers: {headers}""",
                    'full_analysis': """Analyze this dataset and provide:
    1. Key insights and patterns
    2. Data quality issues
    3. Notable correlations
    4. Machine learning potential

    Data Summary: {data_summary}""",
                    'correlation_analysis': """Analyze the correlation matrix and explain:
    1. Strong positive correlations
    2. Strong negative correlations
    3. Important feature relationships

    """
                }
                text_widget.insert('1.0', default_prompts.get(key, ""))
            
            # Buttons container
            button_frame = Frame(section_frame, bg=self.themes[self.current_theme]["bg"])
            button_frame.pack(fill='x', pady=5)
            
            # Save button
            Button(
                button_frame,
                text="Save Prompt",
                command=lambda k=key, t=text_widget: self.save_prompt(k, t.get('1.0', 'end-1c')),
                bg=self.themes[self.current_theme]["accent"],
                fg="#ffffff",
                font=('Segoe UI', 10),
                relief='flat'
            ).pack(side='right', padx=5)
            
            # Reset button
            Button(
                button_frame,
                text="Reset",
                command=lambda k=key, t=text_widget: self.reset_single_prompt(k, t),
                bg=self.themes[self.current_theme]["secondary"],
                fg="#ffffff",
                font=('Segoe UI', 10),
                relief='flat'
            ).pack(side='right', padx=5)
        
        # Add tabs to notebook with improved visibility
        notebook.add(theme_frame, text=" Themes ")
        notebook.add(volume_frame, text=" Volume ")
        notebook.add(help_frame, text=" Help ")
        notebook.add(prompts_main_frame, text=" Prompts ")
        
        def on_close():
            canvas.unbind_all("<MouseWheel>")
            settings_window.destroy()
            
        # Close button with improved visibility
        Button(
            settings_window,
            text="Close",
            command=on_close,
            bg=self.themes[self.current_theme]["accent"],
            fg="#ffffff",
            font=('Segoe UI', 12, 'bold'),
            width=10,
            height=1,
            relief='flat',
            cursor='hand2',
            activebackground=self.themes[self.current_theme]["secondary"],
            activeforeground="#ffffff"
        ).pack(pady=20)
    def load_prompt(self, prompt_type):
        """Load prompt from database"""
        try:
            db_path = os.path.join(get_app_directory(), "config", "prompts.db")
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table if it doesn't exist
            cursor.execute('''CREATE TABLE IF NOT EXISTS prompts
                            (type TEXT PRIMARY KEY, content TEXT)''')
            
            cursor.execute('SELECT content FROM prompts WHERE type = ?', (prompt_type,))
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result else ""
        except Exception as e:
            logging.error(f"Error loading prompt: {str(e)}")
            return ""

    def save_prompt(self, prompt_type, content):
        """Save prompt to database"""
        try:
            db_path = os.path.join(get_app_directory(), "config", "prompts.db")
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table if it doesn't exist
            cursor.execute('''CREATE TABLE IF NOT EXISTS prompts
                            (type TEXT PRIMARY KEY, content TEXT)''')
            
            # Insert or update prompt
            cursor.execute('''INSERT OR REPLACE INTO prompts (type, content)
                            VALUES (?, ?)''', (prompt_type, content))
            
            conn.commit()
            conn.close()
            messagebox.showinfo("Success", "Prompt saved successfully!")
        except Exception as e:
            logging.error(f"Error saving prompt: {str(e)}")
            messagebox.showerror("Error", f"Failed to save prompt: {str(e)}")

    def change_theme(self, theme_name):
        """Change the application theme"""
        if theme_name in self.themes:
            self.current_theme = theme_name
            self.apply_theme(theme_name)
            
    def apply_theme(self, theme_name):
        """Apply the selected theme to all widgets"""
        theme = self.themes[theme_name]
        
        # Update main window
        self.root.configure(bg=theme["bg"])
        self.main_container.configure(bg=theme["bg"])
        self.banner_frame.configure(bg=theme["bg"])
        self.gradient_frame.configure(
            bg=theme["bg"],
            highlightbackground=theme["highlight"]
        )
        self.wave_frame.configure(bg=theme["bg"])
        
        # Update labels
        self.header_label.configure(
            bg=theme["bg"],
            fg=theme["accent"]
        )
        self.subtitle_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.status_label.configure(
            bg=theme["bg"],
            fg=theme["error"] if "Not Listening" in self.status_label.cget("text") else theme["success"]
        )
        
        # Update buttons
        self.settings_button.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        
        # Update text area
        self.output_text.configure(
            bg=theme["text_bg"],
            fg=theme["fg"],
            insertbackground=theme["accent"],
            selectbackground=theme["accent"]
        )
        
        # Update system stats
        self.cpu_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.memory_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.time_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )

    def change_volume(self, value):
        """Change assistant volume"""
        try:
            volume = float(value) / 100  # Convert percentage to float between 0 and 1
            engine.setProperty('volume', volume)
        except Exception as e:
            logging.error(f"Error changing volume: {str(e)}")

   
    def handle_shortcuts(self, command):
        """Handle various shortcut commands with minimal delay"""
        try:
            shortcuts = {
                'save as': lambda: pyautogui.hotkey('ctrl', 'shift', 's'),
                'save': lambda: pyautogui.hotkey('ctrl', 's'),
                'new text file': lambda: pyautogui.hotkey('ctrl', 'n'),
                'new text window': lambda: pyautogui.hotkey('ctrl', 'shift', 'n'),
                'open file': lambda: pyautogui.hotkey('ctrl', 'o'),
                'open folder': lambda: pyautogui.hotkey('ctrl', 'shift', 'o'),
                'undo': lambda: pyautogui.hotkey('ctrl', 'z'),
                'select all': lambda: pyautogui.hotkey('ctrl', 'a'),
                'run window': lambda: pyautogui.hotkey('win', 'r'),
                'copy': lambda: pyautogui.hotkey('ctrl', 'c'),
                'copy all': lambda: (pyautogui.hotkey('ctrl', 'a'), pyautogui.hotkey('ctrl', 'c')),
                'paste': lambda: pyautogui.hotkey('ctrl', 'v'),
                'cut': lambda: pyautogui.hotkey('ctrl', 'x'),
                'find': lambda: pyautogui.hotkey('ctrl', 'f'),
                'close window': lambda: pyautogui.hotkey('alt', 'f4'),
                'switch window': lambda: pyautogui.hotkey('alt', 'tab'),
                'minimize all': lambda: pyautogui.hotkey('win', 'm'),
                'task manager': lambda: pyautogui.hotkey('ctrl', 'shift', 'esc'),
                'lock screen': lambda: pyautogui.hotkey('win', 'l')
            }

            # Set pyautogui settings for faster execution
            pyautogui.PAUSE = 0.1  # Reduce default pause
            pyautogui.MINIMUM_DURATION = 0  # Instant movements

            for shortcut, action in shortcuts.items():
                if shortcut in command:
                    action()
                    self.speak(f"Done")  # Shorter feedback
                    return True
            return False

        except Exception as e:
            logging.error(f"Error executing shortcut: {str(e)}")
            self.speak("Error with shortcut")
            return False
    def load_prompt(self, prompt_type):
        """Load prompt from database"""
        try:
            db_path = os.path.join(get_app_directory(), "config", "prompts.db")
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table if it doesn't exist
            cursor.execute('''CREATE TABLE IF NOT EXISTS prompts
                            (type TEXT PRIMARY KEY, content TEXT)''')
            
            cursor.execute('SELECT content FROM prompts WHERE type = ?', (prompt_type,))
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result else ""
        except Exception as e:
            logging.error(f"Error loading prompt: {str(e)}")
            return ""

    def save_prompt(self, prompt_type, content):
        """Save prompt to database"""
        try:
            db_path = os.path.join(get_app_directory(), "config", "prompts.db")
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table if it doesn't exist
            cursor.execute('''CREATE TABLE IF NOT EXISTS prompts
                            (type TEXT PRIMARY KEY, content TEXT)''')
            
            # Insert or update prompt
            cursor.execute('''INSERT OR REPLACE INTO prompts (type, content)
                            VALUES (?, ?)''', (prompt_type, content))
            
            conn.commit()
            conn.close()
            messagebox.showinfo("Success", "Prompt saved successfully!")
        except Exception as e:
            logging.error(f"Error saving prompt: {str(e)}")
            messagebox.showerror("Error", f"Failed to save prompt: {str(e)}")

    def change_theme(self, theme_name):
        """Change the application theme"""
        if theme_name in self.themes:
            self.current_theme = theme_name
            self.apply_theme(theme_name)
            
    def apply_theme(self, theme_name):
        """Apply the selected theme to all widgets"""
        theme = self.themes[theme_name]
        
        # Update main window
        self.root.configure(bg=theme["bg"])
        self.main_container.configure(bg=theme["bg"])
        self.banner_frame.configure(bg=theme["bg"])
        self.gradient_frame.configure(
            bg=theme["bg"],
            highlightbackground=theme["highlight"]
        )
        self.wave_frame.configure(bg=theme["bg"])
        
        # Update labels
        self.header_label.configure(
            bg=theme["bg"],
            fg=theme["accent"]
        )
        self.subtitle_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.status_label.configure(
            bg=theme["bg"],
            fg=theme["error"] if "Not Listening" in self.status_label.cget("text") else theme["success"]
        )
        
        # Update buttons
        self.settings_button.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        
        # Update text area
        self.output_text.configure(
            bg=theme["text_bg"],
            fg=theme["fg"],
            insertbackground=theme["accent"],
            selectbackground=theme["accent"]
        )
        
        # Update system stats
        self.cpu_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.memory_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )
        self.time_label.configure(
            bg=theme["bg"],
            fg=theme["secondary"]
        )

    def change_volume(self, value):
        """Change assistant volume"""
        try:
            volume = float(value) / 100  # Convert percentage to float between 0 and 1
            engine.setProperty('volume', volume)
        except Exception as e:
            logging.error(f"Error changing volume: {str(e)}")

   
    def handle_shortcuts(self, command):
        """Handle various shortcut commands with minimal delay"""
        try:
            shortcuts = {
                'save as': lambda: pyautogui.hotkey('ctrl', 'shift', 's'),
                'save': lambda: pyautogui.hotkey('ctrl', 's'),
                'new text file': lambda: pyautogui.hotkey('ctrl', 'n'),
                'new text window': lambda: pyautogui.hotkey('ctrl', 'shift', 'n'),
                'open file': lambda: pyautogui.hotkey('ctrl', 'o'),
                'open folder': lambda: pyautogui.hotkey('ctrl', 'shift', 'o'),
                'undo': lambda: pyautogui.hotkey('ctrl', 'z'),
                'select all': lambda: pyautogui.hotkey('ctrl', 'a'),
                'run window': lambda: pyautogui.hotkey('win', 'r'),
                'copy': lambda: pyautogui.hotkey('ctrl', 'c'),
                'copy all': lambda: (pyautogui.hotkey('ctrl', 'a'), pyautogui.hotkey('ctrl', 'c')),
                'paste': lambda: pyautogui.hotkey('ctrl', 'v'),
                'cut': lambda: pyautogui.hotkey('ctrl', 'x'),
                'find': lambda: pyautogui.hotkey('ctrl', 'f'),
                'close window': lambda: pyautogui.hotkey('alt', 'f4'),
                'switch window': lambda: pyautogui.hotkey('alt', 'tab'),
                'minimize all': lambda: pyautogui.hotkey('win', 'm'),
                'task manager': lambda: pyautogui.hotkey('ctrl', 'shift', 'esc'),
                'lock screen': lambda: pyautogui.hotkey('win', 'l')
            }

            # Set pyautogui settings for faster execution
            pyautogui.PAUSE = 0.1  # Reduce default pause
            pyautogui.MINIMUM_DURATION = 0  # Instant movements

            for shortcut, action in shortcuts.items():
                if shortcut in command:
                    action()
                    self.speak(f"Done")  # Shorter feedback
                    return True
            return False

        except Exception as e:
            logging.error(f"Error executing shortcut: {str(e)}")
            self.speak("Error with shortcut")
            return False

    def open_system_app(self, command):
        """Open system applications with proper path handling"""
        # Define common Office paths
        office_paths = {
            '64bit': [
                "C:\\Program Files\\Microsoft Office\\root\\Office16",
                "C:\\Program Files\\Microsoft Office\\Office16",
                "C:\\Program Files (x86)\\Microsoft Office\\root\\Office16",
                "C:\\Program Files (x86)\\Microsoft Office\\Office16"
            ]
        }
        
        app_commands = {
            'word': {
                'name': 'Microsoft Word',
                'cmd': 'WINWORD.EXE',
                'paths': office_paths['64bit']
            },
            'excel': {
                'name': 'Microsoft Excel',
                'cmd': 'EXCEL.EXE',
                'paths': office_paths['64bit']
            },
            'powerpoint': {
                'name': 'Microsoft PowerPoint',
                'cmd': 'POWERPNT.EXE',
                'paths': office_paths['64bit']
            }
        }

        try:
            command = command.lower()
            if command in app_commands:
                app_info = app_commands[command]
                executable_found = False
                
                # Try each possible path
                for base_path in app_info['paths']:
                    full_path = os.path.join(base_path, app_info['cmd'])
                    if os.path.exists(full_path):
                        subprocess.Popen(full_path)
                        executable_found = True
                        break
                
                if not executable_found:
                    error_msg = f"Could not find {app_info['name']}. Please verify it is installed correctly."
                    logging.error(error_msg)
                    messagebox.showerror("Application Error", error_msg)
            else:
                # Handle other system commands here
                pass
                
        except Exception as e:
            error_msg = f"Error opening application: {str(e)}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)

    def search_and_click_first_result(self, search_term):
        """Ultra-fast Windows search and click"""
        try:
            pyautogui.PAUSE = 0.1
            pyautogui.MINIMUM_DURATION = 0
            
            # Open Windows search (Win+S is faster than Win key alone)
            pyautogui.hotkey('win', 's')
            time.sleep(0.1)
            
            # Type instantly
            pyautogui.write(search_term, interval=0.01)
            time.sleep(0.2)
            
            pyautogui.press('enter')
            self.speak(f"Opening {search_term}")
            return True
        except Exception as e:
            logging.error(f"Search error: {str(e)}")
            self.speak("Search error")
            return False

    def create_tron_style_frame(self, parent, has_glow=True):
        """Create a TRON Legacy styled frame"""
        # Create main frame
        frame = Frame(
            parent,
            bg='#0c1221',  # Dark blue background
            highlightbackground='#00f6ff',  # Neon blue border
            highlightthickness=1 if has_glow else 0,
            padx=15,
            pady=15
        )
        
        if has_glow:
            # Create glow effect
            glow = Frame(
                frame,
                bg='#00f6ff',  # Neon blue glow
                height=2
            )
            glow.pack(fill='x', side='top')
            
            # Add bottom glow
            bottom_glow = Frame(
                frame,
                bg='#00f6ff',  # Neon blue glow
                height=2
            )
            bottom_glow.pack(fill='x', side='bottom')
        
        return frame

    def create_tron_button(self, parent, text, command, width=None):
        """Create a TRON Legacy styled button"""
        button_frame = Frame(
            parent,
            bg='#0c1221',
            highlightbackground='#00f6ff',
            highlightthickness=1
        )
        
        button = Button(
            button_frame,
            text=text,
            command=command,
            bg='#0c1221',
            fg='#00f6ff',
            font=('Orbitron', 10, 'bold'),
            relief='flat',
            activebackground='#00f6ff',
            activeforeground='#0c1221',
            cursor='hand2',
            width=width if width else None
        )
        button.pack(padx=1, pady=1)
        
        def on_enter(e):
            button_frame.config(highlightbackground='#00ffff')
            button.config(bg='#0f1a2b')
        
        def on_leave(e):
            button_frame.config(highlightbackground='#00f6ff')
            button.config(bg='#0c1221')
        
        button.bind('<Enter>', on_enter)
        button.bind('<Leave>', on_leave)
        
        return button_frame
    def change_volume(self, value):
        """Change assistant volume"""
        try:
            volume = float(value) / 100  # Convert percentage to float between 0 and 1
            engine.setProperty('volume', volume)
        except Exception as e:
            logging.error(f"Error changing volume: {str(e)}")

   
    def handle_shortcuts(self, command):
        """Handle various shortcut commands with minimal delay"""
        try:
            shortcuts = {
                'save as': lambda: pyautogui.hotkey('ctrl', 'shift', 's'),
                'save': lambda: pyautogui.hotkey('ctrl', 's'),
                'new text file': lambda: pyautogui.hotkey('ctrl', 'n'),
                'new text window': lambda: pyautogui.hotkey('ctrl', 'shift', 'n'),
                'open file': lambda: pyautogui.hotkey('ctrl', 'o'),
                'open folder': lambda: pyautogui.hotkey('ctrl', 'shift', 'o'),
                'undo': lambda: pyautogui.hotkey('ctrl', 'z'),
                'select all': lambda: pyautogui.hotkey('ctrl', 'a'),
                'run window': lambda: pyautogui.hotkey('win', 'r'),
                'copy': lambda: pyautogui.hotkey('ctrl', 'c'),
                'copy all': lambda: (pyautogui.hotkey('ctrl', 'a'), pyautogui.hotkey('ctrl', 'c')),
                'paste': lambda: pyautogui.hotkey('ctrl', 'v'),
                'cut': lambda: pyautogui.hotkey('ctrl', 'x'),
                'find': lambda: pyautogui.hotkey('ctrl', 'f'),
                'close window': lambda: pyautogui.hotkey('alt', 'f4'),
                'switch window': lambda: pyautogui.hotkey('alt', 'tab'),
                'minimize all': lambda: pyautogui.hotkey('win', 'm'),
                'task manager': lambda: pyautogui.hotkey('ctrl', 'shift', 'esc'),
                'lock screen': lambda: pyautogui.hotkey('win', 'l')
            }

            # Set pyautogui settings for faster execution
            pyautogui.PAUSE = 0.1  # Reduce default pause
            pyautogui.MINIMUM_DURATION = 0  # Instant movements

            for shortcut, action in shortcuts.items():
                if shortcut in command:
                    action()
                    self.speak(f"Done")  # Shorter feedback
                    return True
            return False

        except Exception as e:
            logging.error(f"Error executing shortcut: {str(e)}")
            self.speak("Error with shortcut")
            return False

    def open_system_app(self, command):
        """Open system applications with proper path handling"""
        # Define common Office paths
        office_paths = {
            '64bit': [
                "C:\\Program Files\\Microsoft Office\\root\\Office16",
                "C:\\Program Files\\Microsoft Office\\Office16",
                "C:\\Program Files (x86)\\Microsoft Office\\root\\Office16",
                "C:\\Program Files (x86)\\Microsoft Office\\Office16"
            ]
        }
        
        app_commands = {
            'word': {
                'name': 'Microsoft Word',
                'cmd': 'WINWORD.EXE',
                'paths': office_paths['64bit']
            },
            'excel': {
                'name': 'Microsoft Excel',
                'cmd': 'EXCEL.EXE',
                'paths': office_paths['64bit']
            },
            'powerpoint': {
                'name': 'Microsoft PowerPoint',
                'cmd': 'POWERPNT.EXE',
                'paths': office_paths['64bit']
            }
        }

        try:
            command = command.lower()
            if command in app_commands:
                app_info = app_commands[command]
                executable_found = False
                
                # Try each possible path
                for base_path in app_info['paths']:
                    full_path = os.path.join(base_path, app_info['cmd'])
                    if os.path.exists(full_path):
                        subprocess.Popen(full_path)
                        executable_found = True
                        break
                
                if not executable_found:
                    error_msg = f"Could not find {app_info['name']}. Please verify it is installed correctly."
                    logging.error(error_msg)
                    messagebox.showerror("Application Error", error_msg)
            else:
                # Handle other system commands here
                pass
                
        except Exception as e:
            error_msg = f"Error opening application: {str(e)}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)

    def search_and_click_first_result(self, search_term):
        """Ultra-fast Windows search and click"""
        try:
            pyautogui.PAUSE = 0.1
            pyautogui.MINIMUM_DURATION = 0
            
            # Open Windows search (Win+S is faster than Win key alone)
            pyautogui.hotkey('win', 's')
            time.sleep(0.1)
            
            # Type instantly
            pyautogui.write(search_term, interval=0.01)
            time.sleep(0.2)
            
            pyautogui.press('enter')
            self.speak(f"Opening {search_term}")
            return True
        except Exception as e:
            logging.error(f"Search error: {str(e)}")
            self.speak("Search error")
            return False

    def show_contact_manager(self):
        """Show the contact manager window"""
        ContactManager(self.root)

    def show_programming_window(self):
        """Show the programming window for AI code generation"""
        try:
            # First check if Gemini API is available
            try:
                import google.generativeai as genai
                genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            except ImportError:
                self.speak("Please install the google-generativeai package first")
                messagebox.showerror("Missing Dependency", 
                    "Please install the required package:\npip install google-generativeai")
                return
            except Exception as e:
                self.speak("Error initializing Gemini API")
                messagebox.showerror("API Error", f"Failed to initialize Gemini API: {str(e)}")
                return

            # Check if window already exists
            if hasattr(self, 'programming_window') and self.programming_window is not None:
                try:
                    self.programming_window.window.lift()  # Bring existing window to front
                    self.programming_window.window.focus_force()
                    return
                except tk.TclError:  # Window was closed
                    pass

            # Create and store programming window instance
            self.programming_window = ProgrammingWindow(self)
            self.speak("Opening the programming assistant")
            
        except Exception as e:
            self.handle_errors(e, "Error opening programming window")
            self.speak("Sorry, I encountered an error while opening the programming assistant.")
    
    def whatsapp_interaction(self, action, contact_name):
        """Handle WhatsApp interactions with auto-resume listening"""
        try:
            # Store the current listening state
            was_listening = self.start_button._listening
            
            # Temporarily pause listening while handling WhatsApp
            if was_listening:
                self.start_button._listening = False
                self.update_status(False)
            
            # Get contact number from database
            db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'samcontact.db')
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            contact_name = contact_name.strip().lower()
            cursor.execute("SELECT name, number FROM contacts WHERE LOWER(name)=?", (contact_name,))
            results = cursor.fetchall()
            
            if not results:
                cursor.execute("SELECT name, number FROM contacts WHERE LOWER(name) LIKE ?", 
                             ('%' + contact_name + '%',))
                results = cursor.fetchall()
            
            conn.close()
            
            if not results:
                self.speak(f'Contact {contact_name} not found. Please add it using the contact manager.')
                if was_listening:
                    self.root.after(1000, self.resume_listening)
                return False

            # Use the first matching contact
            contact_name = results[0][0]  # Use the actual name from database
            mobile_no = results[0][1]
            # Clean the phone number - remove spaces and special characters
            mobile_no = ''.join(filter(str.isdigit, mobile_no))
            if not mobile_no.startswith('91'):
                mobile_no = '91' + mobile_no

            # Handle different actions using WhatsApp URLs
            if action == 'message':
                self.speak("What message do you want to send?")
                message = self.take_command()
                if not message or message == "none":
                    self.speak("No message was provided")
                    if was_listening:
                        self.root.after(1000, self.resume_listening)
                    return False
                
                # Use WhatsApp URL with message
                url = f"whatsapp://send?phone={mobile_no}&text={quote(message)}"
                webbrowser.open(url)
                time.sleep(3)  # Wait for WhatsApp to open
                pyautogui.press('enter')  # Press enter to send message
                time.sleep(1)
                self.speak(f"Message sent to {contact_name}")
                
            elif action == 'call':
                # Use WhatsApp URL for call
                url = f"whatsapp://call?phone={mobile_no}"
                webbrowser.open(url)
                self.speak(f"Starting WhatsApp call with {contact_name}")
                
            else:  # video call
                # Use WhatsApp URL for video call
                url = f"whatsapp://videocall?phone={mobile_no}"
                webbrowser.open(url)
                self.speak(f"Starting WhatsApp video call with {contact_name}")

            # Resume listening if it was active before
            if was_listening:
                self.root.after(1000, self.resume_listening)
            
            return True
            
        except Exception as e:
            logging.error(f"Error in WhatsApp interaction: {str(e)}")
            self.speak(f"Sorry, I encountered an error: {str(e)}")
            if was_listening:
                self.root.after(1000, self.resume_listening)
            return False

    def resume_listening(self):
        """Resume listening mode"""
        try:
            self.start_button._listening = True
            self.start_button.config(text="◼")  # Change to stop symbol
            self.update_status(True)
            if not hasattr(self, 'listening_thread') or not self.listening_thread.is_alive():
                self.listening_thread = threading.Thread(target=self.listen_for_commands)
                self.listening_thread.daemon = True
                self.listening_thread.start()
            if hasattr(self, 'wave_vis') and self.wave_vis:
                self.wave_vis.start_listening_animation()
            self.status_label.config(text="● Listening", fg='#4CAF50')
        except Exception as e:
            logging.error(f"Error resuming listening: {str(e)}")
            self.speak("Error resuming voice recognition")

    def process_whatsapp_message(self, contact_name):
        """Handle WhatsApp message sending with auto-resume"""
        try:
            # Store the current listening state
            was_listening = self.start_button._listening
            
            print(f"Getting message for contact: {contact_name}")
            self.speak("What message would you like to send?")
            message = self.take_command().lower()
            
            if message:
                print(f"Message to send: {message}")
                result = self.whatsapp_interaction("message", contact_name)
                
                # Resume listening if it was active before
                if was_listening:
                    self.root.after(1000, self.resume_listening)
                return result
                
            # Resume listening if it was active before
            if was_listening:
                self.root.after(1000, self.resume_listening)
            return False
            
        except Exception as e:
            print(f"Error in process_whatsapp_message: {e}")
            self.speak("I couldn't process the message. Please try again.")
            # Resume listening if it was active before
            if was_listening:
                self.root.after(1000, self.resume_listening)
            return False


    def find_element_with_gemini(self, image_path, element_description):
        """Use Gemini Vision API to find UI elements"""
        try:
            import google.generativeai as genai
            from PIL import Image
            
            # Configure Gemini API
            genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            model = genai.GenerativeModel('gemini-2.0-flash')
            
            # Load the image
            image = Image.open(image_path)
            
            # Create the prompt
            prompt = f"""
            Analyze this WhatsApp desktop screenshot and find the exact coordinates of the {element_description}.
            Return ONLY the x,y coordinates in format 'x,y' where the element is located.
            If multiple matches are found, return the most likely one.
            If no match is found, return 'not found'.
            """
            
            # Generate response
            response = model.generate_content([prompt, image])
            result = response.text.strip()
            
            if result and result != 'not found':
                try:
                    x, y = map(int, result.split(','))
                    return (x, y)
                except:
                    return None
            
            return None
            
        except Exception as e:
            logging.error(f"Error using Gemini Vision API: {str(e)}")
            return None

    def control_brightness(self, action):
        """Control system brightness"""
        try:
            current = sbc.get_brightness()[0]
            if 'increase' in action or 'up' in action:
                new_brightness = min(current + 20, 100)
                sbc.set_brightness(new_brightness)
                self.speak(f"Brightness increased to {new_brightness} percent")
            elif 'decrease' in action or 'down' in action:
                new_brightness = max(current - 20, 0)
                sbc.set_brightness(new_brightness)
                self.speak(f"Brightness decreased to {new_brightness} percent")
            elif 'set' in action:
                # Extract number from command if present
                try:
                    level = int(''.join(filter(str.isdigit, action)))
                    level = max(0, min(100, level))
                    sbc.set_brightness(level)
                    self.speak(f"Brightness set to {level} percent")
                except:
                    self.speak("Please specify a brightness level between 0 and 100")
        except Exception as e:
            self.handle_errors(e, "brightness control")
            self.speak("Sorry, I couldn't adjust the brightness")

    def control_volume(self, action):
        """Control system volume"""
        try:
            from ctypes import cast, POINTER
            from comtypes import CLSCTX_ALL
            from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
            
            devices = AudioUtilities.GetSpeakers()
            interface = devices.Activate(IAudioEndpointVolume._iid_, CLSCTX_ALL, None)
            volume = cast(interface, POINTER(IAudioEndpointVolume))
            
            current_vol = round(volume.GetMasterVolumeLevelScalar() * 100)
            
            if 'increase' in action or 'up' in action:
                new_vol = min(current_vol + 10, 100)
                volume.SetMasterVolumeLevelScalar(new_vol / 100, None)
                self.speak(f"Volume increased to {new_vol} percent")
            elif 'decrease' in action or 'down' in action:
                new_vol = max(current_vol - 10, 0)
                volume.SetMasterVolumeLevelScalar(new_vol / 100, None)
                self.speak(f"Volume decreased to {new_vol} percent")
            elif 'set' in action:
                try:
                    level = int(''.join(filter(str.isdigit, action)))
                    level = max(0, min(100, level))
                    volume.SetMasterVolumeLevelScalar(level / 100, None)
                    self.speak(f"Volume set to {level} percent")
                except:
                    self.speak("Please specify a volume level between 0 and 100")
        except Exception as e:
            self.handle_errors(e, "volume control")
            self.speak("Sorry, I couldn't adjust the volume")
    def show_data_analysis_window(self):   
       """Show data analysis window"""
       try:
            analysis_window = tk.Toplevel(self.root)
            analysis_window.title("Data Analysis")
            analysis_window.geometry("1200x800")
            analysis_window.configure(bg=self.themes['Tron Legacy']['bg'])  # Set Tron Legacy background

            # Make window modal
            analysis_window.transient(self.root)
            analysis_window.grab_set()

            # Create notebook for tabs
            notebook = ttk.Notebook(analysis_window)
            notebook.pack(fill='both', expand=True, padx=10, pady=10)

            # Main analysis tab
            main_frame = ttk.Frame(notebook, style='Custom.TFrame')  # Apply custom style
            notebook.add(main_frame, text=" Analysis ")

            # File selection frame
            select_frame = tk.Frame(
                main_frame,
                bg=self.themes['Tron Legacy']['bg']
            )
            select_frame.pack(fill='x', pady=10)

            # Dataset selection button
            select_btn = tk.Button(
                select_frame,
                text="Select Dataset",
                command=lambda: self.load_dataset(analysis_window),
                font=('Segoe UI', 12),
                bg=self.themes['Tron Legacy']['accent'],  # Set Tron Legacy accent
                fg="red",
                    relief='flat',
                    padx=20,
                pady=10,
                cursor='hand2'
            )
            select_btn.pack(side='left', padx=10)

            # Analysis text area
            self.analysis_text = scrolledtext.ScrolledText(
                main_frame,
                wrap=tk.WORD,
                width=80,
                height=30,
                font=('Consolas', 11),
                bg=self.themes['Tron Legacy']['text_bg'],  # Set Tron Legacy text background
                fg=self.themes['Tron Legacy']['fg'],  # Set Tron Legacy foreground
                insertbackground=self.themes['Tron Legacy']['accent']  # Set Tron Legacy insert background
            )
            self.analysis_text.pack(fill='both', expand=True, padx=10, pady=10)

       except Exception as e:
            self.handle_errors(e, "Error showing analysis window")

    def load_dataset(self, window):
        """Load and analyze dataset"""
        try:
            file_path = filedialog.askopenfilename(
                filetypes=[
                    ("CSV files", "*.csv"),
                    ("Excel files", "*.xlsx;*.xls"),
                    ("All files", "*.*")
                ]
            )
            
            if not file_path:
                return

            # Load dataset based on file type
            if file_path.endswith('.csv'):
                df = pd.read_csv(file_path)
            elif file_path.endswith(('.xlsx', '.xls')):
                df = pd.read_excel(file_path)
            else:
                self.speak("Unsupported file format")
                return

            # Clear previous analysis
            self.analysis_text.delete('1.0', tk.END)
            self.analyze_headers(df)
            self.perform_analysis(df)

        except Exception as e:
            self.handle_errors(e, "Error loading dataset")

    def analyze_headers(self, df):
        """Analyze dataset headers using Gemini"""
        try:
            headers = df.columns.tolist()
            
            # Get header analysis prompt from settings
            header_prompt = self.load_prompt('data_header_analysis')
            if not header_prompt:
                header_prompt = """Analyze these dataset headers and provide:
    1. Brief explanation of each header
    2. Potential relationships between headers
    3. What insights could be derived
    4.Don't Include this * "' symbols

    Headers: {headers}"""

            # Format prompt with actual headers
            formatted_prompt = header_prompt.format(headers=headers)

            # Get Gemini's analysis
            response = self.gemini_model.generate_content(formatted_prompt)
            
            if not response or not response.text:
                raise Exception("No response from Gemini API")
                
            # Display results
            self.analysis_text.insert(tk.END, "=== Header Analysis ===\n\n", 'header')
            self.analysis_text.insert(tk.END, response.text + "\n\n", 'insight')
            self.analysis_text.insert(tk.END, "=" * 50 + "\n\n")
            
            # Configure tags for different output types
            self.analysis_text.tag_configure('header', foreground='#00FF00')  # Bright green for header
            self.analysis_text.tag_configure('insight', foreground='#00F2FF')  # Light blue for insights
            self.analysis_text.tag_configure('error', foreground='#FF4D4D')  # Red for errors
            
        except Exception as e:
            error_msg = f"Error analyzing headers: {str(e)}"
            self.handle_errors(e, error_msg)
            self.analysis_text.insert(tk.END, f"\n{error_msg}\n", 'error')

    def perform_analysis(self, df):
        """Perform full dataset analysis"""
        try:
            # Basic statistics
            basic_stats = df.describe()
            
            # Prepare data summary
            data_summary = {
                'shape': df.shape,
                'dtypes': df.dtypes.to_dict(),
                'missing_values': df.isnull().sum().to_dict(),
                'basic_stats': basic_stats.to_dict()
            }
            
            # Get statistical analysis prompt from settings
            stats_prompt = self.load_prompt('data_statistical_analysis')
            if not stats_prompt:
                stats_prompt = """Analyze this dataset and provide:
    1. Key insights and patterns
    2. Data quality issues
    3. Notable statistics
    4. Recommendations
    5.Don't Include this * "' symbols
    Summary: {data_summary}"""

            # Format prompt with actual data
            formatted_prompt = stats_prompt.format(data_summary=data_summary)

            # Get Gemini's analysis
            response = self.gemini_model.generate_content(formatted_prompt)
            
            if not response or not response.text:
                raise Exception("No response from Gemini API")
            
            # Display results
            self.analysis_text.insert(tk.END, "=== Dataset Analysis ===\n\n", 'header')
            self.analysis_text.insert(tk.END, response.text + "\n\n", 'insight')
            self.analysis_text.insert(tk.END, "=== Basic Statistics ===\n\n")
            self.analysis_text.insert(tk.END, str(basic_stats) + "\n\n", 'insight')
            
        except Exception as e:
            error_msg = f"Error performing analysis: {str(e)}"
            self.handle_errors(e, error_msg)
            self.analysis_text.insert(tk.END, f"\n{error_msg}\n", 'error')


    def analyze_correlations(self, corr):
        """Analyze correlations using Gemini"""
        try:
            # Find strong correlations
            strong_correlations = []
            for col1 in corr.columns:
                for col2 in corr.columns:
                    if col1 < col2:
                        correlation = corr.loc[col1, col2]
                        if abs(correlation) > 0.5:
                            strong_correlations.append(
                                f"{col1} - {col2}: {correlation:.2f}"
                            )

            # Get correlation analysis prompt from settings
            corr_prompt = self.load_prompt('data_correlation_analysis')
            if not corr_prompt:
                corr_prompt = """Analyze these correlations and explain:
    1. Strong positive correlations
    2. Strong negative correlations
    3. Key feature relationships
    4. Feature selection recommendations

    Correlations: {correlations}"""

            # Format prompt with actual correlations
            formatted_prompt = corr_prompt.format(correlations=strong_correlations)

            # Get Gemini's analysis
            response = self.gemini_model.generate_content(formatted_prompt)
            
            if not response or not response.text:
                raise Exception("No response from Gemini API")
            
            # Display results
            self.analysis_text.insert(tk.END, "\n=== Correlation Analysis ===\n\n")
            self.analysis_text.insert(tk.END, response.text + "\n\n")
            self.analysis_text.see(tk.END)

        except Exception as e:
            error_msg = f"Error analyzing correlations: {str(e)}"
            self.handle_errors(e, error_msg)
            self.analysis_text.insert(tk.END, f"\n{error_msg}\n")
    def get_battery_info(self):
        """Get battery information"""
        try:
            battery = psutil.sensors_battery()
            if battery:
                percent = battery.percent
                power_plugged = battery.power_plugged
                status = "plugged in" if power_plugged else "not plugged in"
                
                # Calculate time remaining
                if not power_plugged:
                    minutes = battery.secsleft // 60
                    hours = minutes // 60
                    mins = minutes % 60
                    time_left = f"{hours} hours and {mins} minutes remaining"
                else:
                    time_left = "charging"
                
                self.speak(f"Battery is at {percent} percent, {status}, {time_left}")
            else:
                self.speak("No battery detected. This might be a desktop computer.")
        except Exception as e:
            self.handle_errors(e, "battery info")
            self.speak("Sorry, I couldn't get the battery information")

    def get_storage_info(self):
        try:
            total, used, free = shutil.disk_usage("/")
            used_percentage = (used / total) * 100
            message = f"{used_percentage:.1f}% of storage is used"
            self.speak(message)
        except Exception as e:
            self.handle_errors(e, "Error getting storage info")
            self.speak("Sorry, I couldn't get the storage information")

    def get_time_date(self):
        """Get current time and date information"""
        try:
            now = datetime.datetime.now()
            date_str = now.strftime("%B %d, %Y")
            time_str = now.strftime("%I:%M %p")
            day_str = now.strftime("%A")
            
            self.speak(f"Today is {day_str}, {date_str}. The current time is {time_str}")
        except Exception as e:
            self.handle_errors(e, "time and date")
            self.speak("Sorry, I couldn't get the time and date information")
    def analyze_database(self):
        """Open a window to analyze database files with TRON Legacy theme"""
        try:
            # Create database analysis window
            analysis_window = tk.Toplevel(self.root)
            analysis_window.title("Database Analysis - TRON Interface")
            analysis_window.geometry("1000x800")
            analysis_window.configure(bg='#0c1221')  # Dark blue background
            
            # Make window modal
            analysis_window.transient(self.root)
            analysis_window.grab_set()
            
            # Create main container with glow effect
            main_frame = self.create_tron_style_frame(analysis_window)
            main_frame.pack(fill='both', expand=True, padx=20, pady=20)
            
            # Header with TRON style
            header_frame = Frame(main_frame, bg='#0c1221')
            header_frame.pack(fill='x', pady=(0, 20))
            
            Label(
                header_frame,
                text="DATABASE ANALYSIS INTERFACE",
                font=("Orbitron", 24, "bold"),
                bg='#0c1221',
                fg='#00f6ff'
            ).pack(pady=(0, 5))
            
            Label(
                header_frame,
                text="A.N.I.S GRID SEARCH SYSTEM v1.0 ",
                font=("Orbitron", 12),
                bg='#0c1221',
                fg='#0088ff'
            ).pack()
            
            # File selection section with TRON styling
            file_frame = self.create_tron_style_frame(main_frame)
            file_frame.pack(fill='x', pady=(0, 20))
            
            self.db_path_var = tk.StringVar()
            
            # Database path entry with TRON style
            entry_frame = Frame(file_frame, bg='#0c1221')
            entry_frame.pack(fill='x', padx=10)
            
            db_entry = Entry(
                entry_frame,
                textvariable=self.db_path_var,
                font=("Share Tech Mono", 10),
                bg='#0f1a2b',
                fg='#00f6ff',
                insertbackground='#00f6ff',
                relief='flat',
                width=70
            )
            db_entry.pack(side='left', padx=(0, 10))
            
            # Browse button with TRON style
            browse_btn = self.create_tron_button(entry_frame, "BROWSE", self.browse_database)
            browse_btn.pack(side='left')
            
            # Search section with TRON styling
            search_frame = self.create_tron_style_frame(main_frame)
            search_frame.pack(fill='x', pady=(0, 20))
            
            Label(
                search_frame,
                text="ENTER QUERY PARAMETERS:",
                font=("Orbitron", 12),
                bg='#0c1221',
                fg='#00f6ff'
            ).pack(anchor='w', pady=(0, 5))
            
            # Search entry with TRON style
            self.search_entry = Text(
                search_frame,
                height=3,
                font=("Share Tech Mono", 10),
                bg='#0f1a2b',
                fg='#00f6ff',
                insertbackground='#00f6ff',
                wrap=WORD,
                relief='flat'
            )
            self.search_entry.pack(fill='x', pady=(0, 10))
            
            # Analyze button with TRON style
            analyze_btn = self.create_tron_button(search_frame, "ANALYZE", self.perform_database_analysis, width=20)
            analyze_btn.pack(pady=10)
            
            # Results section with TRON styling
            results_frame = self.create_tron_style_frame(main_frame)
            results_frame.pack(fill='both', expand=True)
            
            Label(
                results_frame,
                text="ANALYSIS OUTPUT:",
                font=("Orbitron", 12),
                bg='#0c1221',
                fg='#00f6ff'
            ).pack(anchor='w', pady=(0, 5))
            
            # Results text widget with TRON style
            results_container = Frame(
                results_frame,
                bg='#0c1221',
                highlightbackground='#00f6ff',
                highlightthickness=1
            )
            results_container.pack(fill='both', expand=True)
            
            self.results_text = Text(
                results_container,
                wrap=WORD,
                font=("Share Tech Mono", 10),
                bg='#0f1a2b',
                fg='#00f6ff',
                insertbackground='#00f6ff',
                relief='flat',
                padx=10,
                pady=10
            )
            self.results_text.pack(side='left', fill='both', expand=True)
            
            # Custom scrollbar with TRON style
            scrollbar = ttk.Scrollbar(
                results_container,
                orient='vertical',
                command=self.results_text.yview
            )
            scrollbar.pack(side='right', fill='y')
            
            # Configure scrollbar style
            style = ttk.Style()
            style.configure(
                "Tron.Vertical.TScrollbar",
                troughcolor='#0c1221',
                background='#00f6ff',
                arrowcolor='#00f6ff',
                bordercolor='#00f6ff',
                lightcolor='#00f6ff',
                darkcolor='#00f6ff'
            )
            scrollbar.configure(style="Tron.Vertical.TScrollbar")
            
            self.results_text['yscrollcommand'] = scrollbar.set
            
            # Configure tags for different types of text
            self.results_text.tag_configure(
                'header',
                foreground='#00ffff',
                font=("Share Tech Mono", 11, 'bold')
            )
            self.results_text.tag_configure(
                'sql',
                foreground='#0088ff',
                font=("Share Tech Mono", 10, 'italic')
            )
            self.results_text.tag_configure(
                'data',
                foreground='#00f6ff'
            )
            self.results_text.tag_configure(
                'error',
                foreground='#ff0055'
            )
            
        except Exception as e:
            logging.error(f"Error creating database analysis window: {str(e)}")
            messagebox.showerror("Error", "Failed to create analysis window")

    def perform_database_analysis(self):
        """Analyze the database based on user query with TRON-style output"""
        try:
            db_path = self.db_path_var.get()
            search_query = self.search_entry.get('1.0', 'end-1c').strip()
            
            if not db_path:
                messagebox.showwarning("Warning", "Please select a database file")
                return
                
            if not search_query:
                messagebox.showwarning("Warning", "Please enter a search query")
                return
                
            # Connect to database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Clear previous results
            self.results_text.delete('1.0', END)
            
            # Add header
            self.results_text.insert(END, "INITIATING DATABASE ANALYSIS...\n", 'header')
            self.results_text.insert(END, "=" * 50 + "\n\n", 'header')
            
            # Get all table names
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = cursor.fetchall()
            
            # Use Gemini to analyze the query and generate SQL
            try:
                import google.generativeai as genai
                genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
                model = genai.GenerativeModel('gemini-2.0-flash')
                
                # Prepare database schema information
                schema_info = []
                for table in tables:
                    table_name = table[0]
                    cursor.execute(f"PRAGMA table_info({table_name});")
                    columns = cursor.fetchall()
                    schema_info.append(f"Table: {table_name}")
                    schema_info.append("Columns: " + ", ".join(col[1] for col in columns))
                    try:
                        cursor.execute(f"SELECT * FROM {table_name} LIMIT 1")
                        sample_data = cursor.fetchone()
                        if sample_data:
                            schema_info.append(f"Sample data: {sample_data}")
                    except:
                        pass
                
                # Create prompt for Gemini
                prompt = f"""Given this database schema:
                {chr(10).join(schema_info)}
                
                User query: {search_query}
                
                Important instructions:
                1. Generate only pure SQL queries without any markdown formatting or backticks
                2. Each query should end with a semicolon
                3. Use SQL wildcards (%) for flexible text matching
                4. Consider all possible matching patterns
                5. If searching text, use both LIKE and alternative matching methods
                6. Return only the SQL queries, no explanations or formatting
                
                Example format:
                SELECT * FROM table WHERE column LIKE '%text%';
                """
                
                response = model.generate_content(prompt)
                sql_text = response.text.strip()
                
                # Clean the SQL queries
                sql_text = sql_text.replace('```sql', '').replace('```', '').strip()
                sql_queries = [q.strip() for q in sql_text.split(';') if q.strip()]
                
                # Execute queries and format results
                executed_queries = set()
                
                for query in sql_queries:
                    if not query or query in executed_queries:
                        continue
                        
                    executed_queries.add(query)
                    
                    try:
                        # Add COLLATE NOCASE for case-insensitive text search if needed
                        if 'LIKE' in query.upper() and 'COLLATE NOCASE' not in query.upper():
                            query = query.replace('LIKE', 'COLLATE NOCASE LIKE')
                        
                        self.results_text.insert(END, "\nEXECUTING QUERY:\n", 'header')
                        self.results_text.insert(END, f"{query}\n\n", 'sql')
                        
                        cursor.execute(query)
                        results = cursor.fetchall()
                        
                        if results:
                            # Get column names
                            col_names = [description[0] for description in cursor.description]
                            
                            # Format column headers
                            self.results_text.insert(END, "COLUMNS: ", 'header')
                            self.results_text.insert(END, " | ".join(col_names) + "\n", 'data')
                            self.results_text.insert(END, "-" * 50 + "\n", 'data')
                            
                            # Format each row
                            for row in results:
                                formatted_row = []
                                for item in row:
                                    if item is None:
                                        formatted_row.append("NULL")
                                    else:
                                        formatted_row.append(str(item))
                                self.results_text.insert(END, " | ".join(formatted_row) + "\n", 'data')
                            
                            self.results_text.insert(END, "\n" + "="*50 + "\n", 'header')
                            
                        else:
                            self.results_text.insert(END, "NO RESULTS FOUND\n", 'error')
                            
                    except sqlite3.Error as e:
                        error_msg = f"ERROR IN QUERY: {str(e)}\n"
                        self.results_text.insert(END, error_msg, 'error')
                
                if not executed_queries:
                    self.results_text.insert(END, "\nNO VALID QUERIES GENERATED\n", 'error')
                    self.results_text.insert(END, "\nTIPS:\n", 'header')
                    self.results_text.insert(END, "- Try different search terms\n", 'data')
                    self.results_text.insert(END, "- Check table and column names\n", 'data')
                    self.results_text.insert(END, "- Verify database contains expected data\n", 'data')
                
            except Exception as e:
                self.results_text.insert(END, f"ANALYSIS ERROR: {str(e)}\n", 'error')
                self.results_text.insert(END, "Please try rephrasing your query.\n", 'data')
                logging.error(f"Analysis error: {str(e)}")
            
            finally:
                conn.close()
                
        except Exception as e:
            logging.error(f"Database analysis error: {str(e)}")
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")

    def browse_database(self):
        """Open file dialog to select database file"""
        try:
            file_path = filedialog.askopenfilename(
                title="Select Database File",
                filetypes=[("Database files", "*.db"), ("All files", "*.*")]
            )
            if file_path:
                self.db_path_var.set(file_path)
        except Exception as e:
            logging.error(f"Error browsing database: {str(e)}")
            messagebox.showerror("Error", "Failed to open file dialog")
class GeminiChatWindow:
    def __init__(self, parent):
        self.window = tk.Toplevel(parent.root)  # Use parent.root for Tkinter window
        self.window.title("Gemini Chat")
        self.window.geometry("800x600")
        self.window.configure(bg='#0C141F')
        
        # Store the main application instance as parent
        self.main_app = parent  # Store the main app instance instead of Tkinter window
        
        # Initialize other attributes
        self.is_reading = False
        self.current_highlight_tag = None
        self.loading = False
        self.processing = False # Add flag to prevent duplicate sends
        
        # Initialize Gemini
        try:
            import google.generativeai as genai
            genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            self.model = genai.GenerativeModel('gemini-2.0-flash')
            self.chat = self.model.start_chat(history=[])
        except Exception as e:
            messagebox.showerror("Error", f"Failed to initialize Gemini: {str(e)}")
            self.window.destroy()
            return
            
        self.create_widgets()
        self.center_window()
        self.engine = pyttsx3.init()
        
        # Make window modal
        self.window.transient(parent.root)
        self.window.grab_set()
        
        # Bind shortcuts and window close event
        self.bind_shortcuts()
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)

    def bind_shortcuts(self):
        """Bind keyboard shortcuts to window"""
        self.window.bind('<Control-Return>', self.handle_send)  # Ctrl+Enter to send
        self.window.bind('<Control-s>', lambda e: self.save_chat())         # Ctrl+S to save
        self.window.bind('<Control-l>', lambda e: self.clear_chat())        # Ctrl+L to clear
        self.window.bind('<Escape>', lambda e: self.stop_reading())         # Esc to stop reading
        self.window.bind('<Control-m>', lambda e: self.toggle_mode())       # Ctrl+M to toggle mode
        self.window.bind('<F1>', lambda e: self.show_shortcuts())           # F1 for help
        
        # Bind to input text widget for better control
        self.input_text.bind('<Control-Return>', self.handle_send)

    def handle_send(self, event=None):
        """Handle send message event to prevent duplicates"""
        if not self.processing:
            self.send_message()
        return "break"  # Prevent event from propagating
    def load_prompt(self, prompt_type):
        """Load prompt from database"""
        try:
            db_path = os.path.join(get_app_directory(), "config", "prompts.db")
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Create table if it doesn't exist
            cursor.execute('''CREATE TABLE IF NOT EXISTS prompts
                            (type TEXT PRIMARY KEY, content TEXT)''')
            
            cursor.execute('SELECT content FROM prompts WHERE type = ?', (prompt_type,))
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result else ""
        except Exception as e:
            logging.error(f"Error loading prompt: {str(e)}")
            return ""
    def create_widgets(self):
        # Create tooltip class
        class ToolTip(object):
            def __init__(self, widget, text):
                self.widget = widget
                self.text = text
                self.tooltip = None
                self.widget.bind('<Enter>', self.enter)
                self.widget.bind('<Leave>', self.leave)

            def enter(self, event=None):
                x, y, _, _ = self.widget.bbox("insert")
                x += self.widget.winfo_rootx() + 25
                y += self.widget.winfo_rooty() + 20
                self.tooltip = tk.Toplevel(self.widget)
                self.tooltip.wm_overrideredirect(True)
                self.tooltip.wm_geometry(f"+{x}+{y}")
                label = tk.Label(self.tooltip, text=self.text, 
                               justify='left',
                               background="#ffffe0", relief='solid', borderwidth=1,
                               font=("Segoe UI", "8", "normal"))
                label.pack()

            def leave(self, event=None):
                if self.tooltip:
                    self.tooltip.destroy()
                    self.tooltip = None

        # Mode selection frame
        mode_frame = tk.Frame(self.window, bg='#0C141F')
        mode_frame.pack(fill='x', padx=20, pady=10)
        
        self.mode_var = tk.StringVar(value="chat")
        
        chat_btn = tk.Radiobutton(
            mode_frame, text="Chat Mode (Ctrl+M)", variable=self.mode_var,
            value="chat", bg='#0C141F', fg='#00F2FF',
            selectcolor='#1D2733', font=('Orbitron', 10)
        )
        chat_btn.pack(side='left', padx=10)
        
        article_btn = tk.Radiobutton(
            mode_frame, text="Article Mode (Ctrl+M)", variable=self.mode_var,
            value="article", bg='#0C141F', fg='#00F2FF',
            selectcolor='#1D2733', font=('Orbitron', 10)
        )
        article_btn.pack(side='left', padx=10)

        # Chat display with tags for different colors
        self.chat_display = scrolledtext.ScrolledText(
            self.window, wrap=tk.WORD, height=20,
            bg='#1D2733', fg='#00F2FF',
            font=('Consolas', 10)
        )
        self.chat_display.pack(fill='both', expand=True, padx=20, pady=10)
        self.chat_display.bind('<Button-1>', self.start_reading_line)

        # Configure tags with new colors
        self.chat_display.tag_configure('user', foreground='#48BB78')      # Fresh green
        self.chat_display.tag_configure('assistant', foreground='#63B3ED')  # Bright blue
        self.chat_display.tag_configure('system', foreground='#9AE6B4')    # Light green
        self.chat_display.tag_configure('highlight', background='#4A5568') # Slate blue
        self.chat_display.tag_configure('error', foreground='#FC8181')     # Soft red

        # Loading indicator
        self.loading_label = tk.Label(
            self.window,
            text="",
            bg='#1D2733',
            fg='#00F2FF',
            font=('Consolas', 10)
        )
        self.loading_label.pack(fill='x', padx=20)
        self.loading_label.pack_forget()  # Hide initially

        # Input frame
        input_frame = tk.Frame(self.window, bg='#0C141F')
        input_frame.pack(fill='x', padx=20, pady=10)

        # Input text
        self.input_text = tk.Text(
            input_frame, height=3, wrap=tk.WORD,
            bg='#1D2733', fg='#00F2FF',
            font=('Consolas', 10)
        )
        self.input_text.pack(side='left', fill='x', expand=True)

        # Buttons frame
        button_frame = tk.Frame(self.window, bg='#0C141F')
        button_frame.pack(fill='x', padx=20, pady=10)

        # Create buttons with tooltips
        buttons = [
            ("Send (Ctrl+Enter)", self.send_message),
            ("Save (Ctrl+S)", self.save_chat),
            ("Clear (Ctrl+L)", self.clear_chat),
            ("Stop Reading (Esc)", self.stop_reading)
        ]

        for text, command in buttons:
            btn = tk.Button(
                button_frame, text=text.split(' (')[0],
                command=command,
                bg='#00F2FF', fg='#0C141F',
                font=('Orbitron', 10, 'bold'),
                relief='flat', padx=20, pady=5
            )
            btn.pack(side='left', padx=5)
            
            # Add hover effects
            btn.bind('<Enter>', lambda e, b=btn: b.configure(bg='#66F9FF'))
            btn.bind('<Leave>', lambda e, b=btn: b.configure(bg='#00F2FF'))
            
            # Add tooltip
            ToolTip(btn, text)

        # Add help button
        help_btn = tk.Button(
            button_frame,
            text="?",
            command=self.show_shortcuts,
            bg='#4CAF50', fg='white',
            font=('Orbitron', 10, 'bold'),
            relief='flat', padx=10, pady=5
        )
        help_btn.pack(side='right', padx=5)
        ToolTip(help_btn, "Show Shortcuts (F1)")

    def toggle_mode(self, event=None):
        """Toggle between chat and article mode"""
        current_mode = self.mode_var.get()
        new_mode = "article" if current_mode == "chat" else "chat"
        self.mode_var.set(new_mode)
        self.chat_display.insert(tk.END, f"\nSwitched to {new_mode} mode\n", 'system')
        self.chat_display.see(tk.END)

    def show_shortcuts(self, event=None):
        """Show keyboard shortcuts help"""
        shortcuts = """
        Keyboard Shortcuts:
        ─────────────────
        Ctrl + Enter : Send message
        Ctrl + S     : Save chat
        Ctrl + L     : Clear chat
        Ctrl + M     : Toggle mode
        Esc         : Stop reading
        F1          : Show this help
        
        Mouse Shortcuts:
        ───────────────
        Click on text : Read line
        Click again   : Stop reading
        """
        messagebox.showinfo("Keyboard Shortcuts", shortcuts, parent=self.window)

    def show_loading(self, show=True):
        if show:
            self.loading = True
            self.loading_label.config(text="Generating response...")
            self.loading_label.pack(fill='x', padx=20, pady=(0, 10))
            self.animate_loading()
        else:
            self.loading = False
            self.loading_label.pack_forget()

    def animate_loading(self):
        if not self.loading:
            return

        dots = self.loading_label.cget("text").count(".")
        new_dots = "." * ((dots + 1) % 4)
        self.loading_label.config(text=f"Generating response{new_dots}")
        self.window.after(500, self.animate_loading)

    def send_message(self):
        if self.processing:  # Prevent duplicate sends
            return

        message = self.input_text.get("1.0", tk.END).strip()
        if not message:
            return

        self.processing = True  # Set processing flag
        # Disable input while processing
        self.input_text.config(state='disabled')
        mode = self.mode_var.get()
        
        # Insert user message with user tag
        self.chat_display.insert(tk.END, "\nYou: ", 'user')
        self.chat_display.insert(tk.END, f"{message}\n")
        self.chat_display.see(tk.END)

        # Show loading indicator
        self.show_loading()

        # Process message in separate thread
        threading.Thread(target=self._process_message, args=(message, mode), daemon=True).start()

    def _process_message(self, message, mode):
        try:
            if mode == "chat":
                custom_prompt = self.main_app.load_prompt('chat_window')
                if custom_prompt:
                    prompt = f"""{custom_prompt}You should answer like intelligent friend.Don't mention your name gemini when someone ask you name instead of this tell 
 your name is ANIS AI integrated with Operation System With Help Of Gemini and under Developing by 
         Samiulla from 26 August 2024 -- don't  tell this in beginning of your response you should tell only when someone ask you name.Please provide clear, 
                well-structured responses and chat like friend and funny way ,without using asterisks or code blocks unless specifically 
                needed for code examples.Full Form Of Your Name is Artificial Neural Intelligence System .Should be short like 2 lines and sweet.Format your response in a professional, educational manner.Don't read the symbols 
                like dot,comma,exclamation mark,question mark,etc in your response\n\nUser Query: {message}"""
                else:
                    prompt = f"""you should answer like intelligent friend.Don't mention your name gemini when someone ask you name instead of this tell 
 your name is ANIS AI integrated with Operation System With Help Of Gemini and under Developing by 
         Samiulla from 26 August 2024 -- don't  tell this in beginning of your response you should tell only when someone ask you name.Please provide clear, 
                well-structured responses and chat like friend and funny way ,without using asterisks or code blocks unless specifically 
                needed for code examples.Full Form Of Your Name is Artificial Neural Intelligence System .Should be short like 2 lines and sweet.Format your response in a professional, educational manner.Don't read the symbols 
                like dot,comma,exclamation mark,question mark,etc in your response \n\nUser Query: {message}"""
                    
            else:  # article mode
                custom_prompt = self.main_app.load_prompt('article_mode')
                if custom_prompt:
                    prompt = f"""{custom_prompt} ,You are a professional teacher/expert.Don't mention your name gemini when someone ask you name instead of this tell 
                  your name is A N I S AI integrated with Operation System With Help Of Gemini and under Developing by 
                  Samiulla from 26 August 2024 -- don't  tell this in beginning of your response you should tell only when someone ask you name.Please provide clear, 
                well-structured article responses without using asterisks or code blocks unless specifically 
                needed for code examples.Full Form Of Your Name is Artificial Neural Intelligence System .Should be short and sweet.Format your response in a professional, 
                educational manner.Don't read the symbols like dot,comma,exclamation mark,question mark,etc in your response\n\n{message}"""
                else:
                    prompt = f"""You are a professional teacher/expert.Don't mention your name gemini when someone ask you name instead of this tell 
 your name is ANIS AI integrated with Operation System With Help Of Gemini and under Developing by 
         Samiulla from 26 August 2024 -- don't  tell this in beginning of your response you should tell only when someone ask you name.Please provide clear, 
                well-structured responses and chat like friend and funny way ,without using asterisks or code blocks unless specifically 
                needed for code examples.Full Form Of Your Name is Artificial Neural Intelligence System .Should be short like 2 lines and sweet.Format your response in a professional, educational manner.Don't read the symbols 
                like dot,comma,exclamation mark,question mark,etc in your response \n\n User Query:{message}"""
            response = self.model.generate_content(prompt)
            response_text = response.text

            # Clean up the response text
            response_text = response_text.replace('*', '')
            response_text = response_text.replace('```', '')
            response_text = response_text.strip()

            # Update UI in main thread
            self.window.after(0, self._update_chat_display, response_text)
        except Exception as e:
            self.window.after(0, self._show_error, str(e))
        finally:
            self.window.after(0, self._reset_processing)

    def _reset_processing(self):
        """Reset processing flag"""
        self.processing = False

    def _update_chat_display(self, response_text):
        self.chat_display.insert(tk.END, "\nResponse: ", 'assistant')
        self.chat_display.insert(tk.END, f"{response_text}\n")
        self.chat_display.see(tk.END)
        self.show_loading(False)
        self.input_text.config(state='normal')
        self.input_text.delete("1.0", tk.END)

    def _show_error(self, error_message):
        self.chat_display.insert(tk.END, f"\nError: {error_message}\n", 'error')
        self.chat_display.see(tk.END)
        self.show_loading(False)
        self.input_text.config(state='normal')

    def start_reading_line(self, event):
        if self.is_reading:
            self.stop_reading()
            return

        try:
            # Remove previous highlight if exists
            if self.current_highlight_tag:
                self.chat_display.tag_remove('highlight', '1.0', tk.END)

            # Get the line under cursor
            index = self.chat_display.index(f"@{event.x},{event.y}")
            line_start = f"{index} linestart"
            line_end = f"{index} lineend"
            line = self.chat_display.get(line_start, line_end)

            if line.strip():
                # Highlight the current line
                self.chat_display.tag_add('highlight', line_start, line_end)
                self.current_highlight_tag = (line_start, line_end)
                
                self.is_reading = True
                threading.Thread(target=self.read_text, args=(line,), daemon=True).start()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read line: {str(e)}")

    def stop_reading(self):
        self.is_reading = False
        self.engine.stop()
        
        # Remove highlight
        if self.current_highlight_tag:
            self.chat_display.tag_remove('highlight', '1.0', tk.END)
            self.current_highlight_tag = None

    def read_text(self, text):
        try:
            self.engine.say(text)
            self.engine.runAndWait()
        finally:
            self.is_reading = False
            # Remove highlight after reading
            self.window.after(0, self.remove_highlight)

    def remove_highlight(self):
        if self.current_highlight_tag:
            self.chat_display.tag_remove('highlight', '1.0', tk.END)
            self.current_highlight_tag = None

    def save_chat(self, event=None):
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
            )
            if file_path:
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(self.chat_display.get("1.0", tk.END))
                messagebox.showinfo("Success", "Chat saved successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save chat: {str(e)}")

    def clear_chat(self, event=None):
        if messagebox.askyesno("Confirm", "Are you sure you want to clear the chat?"):
            self.chat_display.delete("1.0", tk.END)
            self.chat = self.model.start_chat(history=[])

    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')

    def on_closing(self):
        """Handle window closing properly"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                self.stop_reading()  # Stop any ongoing reading
                self.window.grab_release()
                self.window.destroy()
        except Exception as e:
            logging.error(f"Error closing window: {e}")

    
class SummarizeWindow:
    def __init__(self, parent):
        if not parent.winfo_exists():
            raise RuntimeError("Parent window no longer exists")
            
        self.window = tk.Toplevel(parent)
        self.window.title("Smart Notes Generator")
        self.window.geometry("800x600")
        self.window.configure(bg='#1a237e')
        
        # Store reference to parent
        self.parent = parent
        
        # Make window modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Create the GUI elements
        self.create_widgets()
        
        # Center the window
        self.center_window()
        
        # Bind window close event
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)

    def on_closing(self):
        """Handle window closing properly"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                self.window.grab_release()
                self.window.destroy()
        except Exception as e:
            logging.error(f"Error closing window: {e}")

    def cleanup_progress(self):
        """Clean up progress bar and reset button state"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                if hasattr(self, 'progress_bar'):
                    self.progress_bar.stop()
                    self.progress_bar.pack_forget()
                if hasattr(self, 'convert_btn'):
                    self.convert_btn.config(state='normal')
        except Exception as e:
            logging.error(f"Error cleaning up progress: {e}")

    def update_notes(self, notes):
        """Update the output text with generated notes"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                if hasattr(self, 'output_text'):
                    self.output_text.config(state=tk.NORMAL)
                    self.output_text.delete("1.0", tk.END)
                    self.output_text.insert("1.0", notes)
                    self.output_text.config(state=tk.DISABLED)
                if hasattr(self, 'status_label'):
                    self.status_label.config(text="Notes generated successfully")
        except Exception as e:
            logging.error(f"Error updating notes: {e}")
            self.show_error("Failed to update notes display")

    def show_error(self, error_msg):
        """Show error message to user"""
        try:
            if hasattr(self, 'window') and self.window.winfo_exists():
                messagebox.showerror("Error", f"Failed to convert notes: {error_msg}", parent=self.window)
                if hasattr(self, 'status_label'):
                    self.status_label.config(text="Error generating notes")
        except Exception as e:
            logging.error(f"Error showing error message: {e}")

    def convert_to_notes(self):
        # Get the input text
        input_text = self.input_text.get('1.0', tk.END).strip()
        if not input_text:
            messagebox.showwarning("Warning", "Please enter some text to convert.", parent=self.window)
            return

        # Get selected format
        format_type = self.format_var.get()
        
        def run_conversion():
            try:
                # Show progress
                self.progress_bar["value"] = 20
                self.window.update_idletasks()
                
                # Convert text to notes based on format
                notes = self.basic_note_conversion(input_text, format_type)
                
                # Update progress
                self.progress_bar["value"] = 60
                self.window.update_idletasks()
                
                # Post-process the notes
                final_notes = self.post_process_notes(notes, format_type)
                
                # Update progress
                self.progress_bar["value"] = 100
                self.window.update_idletasks()
                
                # Create and show the output window with the notes
                NotesOutputWindow(self.window, final_notes)
                
                # Reset progress bar
                self.cleanup_progress()
                
            except Exception as e:
                self.show_error(f"Error during conversion: {str(e)}")
                self.cleanup_progress()
        
        # Start conversion in a separate thread
        threading.Thread(target=run_conversion, daemon=True).start()

    def create_widgets(self):
        # Main frame with padding
        main_frame = tk.Frame(self.window, bg='#1a237e')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Title with better styling
        title_frame = tk.Frame(main_frame, bg='#1a237e')
        title_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(
            title_frame,
            text="Smart Notes Generator",
            font=("Segoe UI", 24, "bold"),
            bg='#1a237e',
            fg='white'
        ).pack(side='left')

        # Input section
        input_frame = tk.Frame(main_frame, bg='#1a237e')
        input_frame.pack(fill='both', expand=True)
        
        # Input label
        tk.Label(
            input_frame,
            text="Input Text:",
            font=("Segoe UI", 12),
            bg='#1a237e',
            fg='white'
        ).pack(anchor='w', pady=(0, 5))
        
        # Input text with scrollbar
        input_text_frame = tk.Frame(input_frame, bg='#1a237e')
        input_text_frame.pack(fill='both', expand=True, pady=10)
        
        input_scroll = ttk.Scrollbar(input_text_frame)
        input_scroll.pack(side='right', fill='y')
        
        self.input_text = tk.Text(
            input_text_frame,
            height=12,
            bg='#283593',
            fg='white',
            font=("Segoe UI", 11),
                wrap=tk.WORD,
            insertbackground='white',
            yscrollcommand=input_scroll.set
        )
        self.input_text.pack(side='left', fill='both', expand=True)
        input_scroll.config(command=self.input_text.yview)
        
        # Format selection frame below input text
        format_frame = tk.Frame(main_frame, bg='#1a237e')
        format_frame.pack(fill='x', pady=10)
        
        tk.Label(
            format_frame,
            text="Select Note Format:",
            font=("Segoe UI", 12),
            bg='#1a237e',
            fg='white'
        ).pack(anchor='w', pady=(0, 5))
        
        # Format options in a grid layout
        self.format_var = tk.StringVar(value="bullet")
        formats = {
            "bullet": "• Bullet Points",
            "mindmap": "🔄 Mind Map",
            "numbered": "1. Numbered List",
            "outline": "I. Outline Format",
            "cornell": "📝 Cornell Notes"
        }
        
        options_frame = tk.Frame(format_frame, bg='#1a237e')
        options_frame.pack(fill='x', pady=5)
        
        for i, (value, text) in enumerate(formats.items()):
            radio_btn = tk.Radiobutton(
                options_frame,
                text=text,
                variable=self.format_var,
                value=value,
                bg='#1a237e',
                fg='white',
                selectcolor='#283593',
                activebackground='#1a237e',
                activeforeground='white',
                font=("Segoe UI", 11)
            )
            radio_btn.grid(row=i//3, column=i%3, padx=10, pady=5, sticky='w')
        
        # Controls frame
        controls_frame = tk.Frame(main_frame, bg='#1a237e')
        controls_frame.pack(fill='x', pady=10)
        
        # Progress bar (hidden initially)
        self.progress_frame = tk.Frame(controls_frame, bg='#1a237e')
        self.progress_frame.pack(fill='x')
        
        self.progress_bar = ttk.Progressbar(
            self.progress_frame,
            mode='indeterminate',
            length=300
        )
        
        # Buttons frame
        buttons_frame = tk.Frame(controls_frame, bg='#1a237e')
        buttons_frame.pack(pady=10)
        
        # Convert button
        self.convert_btn = tk.Button(
            buttons_frame,
            text="🔄 Convert to Notes",
            command=self.convert_to_notes,
            bg='#4361ee',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2',
            width=15,
            height=1
        )
        self.convert_btn.pack(side='left', padx=5)
        
        # Clear button
        self.clear_btn = tk.Button(
            buttons_frame,
            text="🗑️ Clear",
            command=self.clear_text,
            bg='#FF5252',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2',
            width=10,
            height=1
        )
        self.clear_btn.pack(side='left', padx=5)
        
        # Output section
        output_frame = tk.Frame(main_frame, bg='#1a237e')
        output_frame.pack(fill='both', expand=True)
        
        # Output label frame
        output_label_frame = tk.Frame(output_frame, bg='#1a237e')
        output_label_frame.pack(fill='x')
        
        tk.Label(
            output_label_frame,
            text="Generated Notes:",
            font=("Segoe UI", 12),
            bg='#1a237e',
            fg='white'
        ).pack(side='left')
        
        # Save and export buttons
        button_frame = tk.Frame(output_label_frame, bg='#1a237e')
        button_frame.pack(side='right')
        
        self.save_btn = tk.Button(
            button_frame,
            text="💾 Save",
            command=self.save_notes,
            bg='#4CAF50',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        )
        self.save_btn.pack(side='right', padx=5)
        
        self.export_btn = tk.Button(
            button_frame,
            text="📤 Export",
            command=self.export_notes,
            bg='#FF9800',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        )
        self.export_btn.pack(side='right', padx=5)
        
        # Output text with scrollbar
        output_text_frame = tk.Frame(output_frame, bg='#1a237e')
        output_text_frame.pack(fill='both', expand=True, pady=10)
        
        output_scroll = ttk.Scrollbar(output_text_frame)
        output_scroll.pack(side='right', fill='y')
        
        self.output_text = tk.Text(
            output_text_frame,
            height=12,
            bg='#283593',
            fg='white',
            font=("Segoe UI", 11),
            wrap=tk.WORD,
            yscrollcommand=output_scroll.set
        )
        self.output_text.pack(side='left', fill='both', expand=True)
        output_scroll.config(command=self.output_text.yview)
        
        # Status bar
        self.status_label = tk.Label(
            main_frame,
            text="Ready",
            font=("Segoe UI", 10),
            bg='#1a237e',
            fg='#8f9aff'
        )
        self.status_label.pack(pady=(10, 0))

    def post_process_notes(self, notes, format_type):
        """Post-process generated notes for better formatting"""
        if format_type == "bullet":
            # Ensure proper bullet point hierarchy
            lines = notes.split('\n')
            processed_lines = []
            for line in lines:
                line = line.strip()
                if line:
                    if not line.startswith('•'):
                        line = '• ' + line
                    # Add sub-points with different bullets
                    if line.startswith('• • '):
                        line = '  ○ ' + line.replace('• • ', '')
                    elif line.startswith('• • • '):
                        line = '    ▪ ' + line.replace('• • • ', '')
                processed_lines.append(line)
            return '\n'.join(processed_lines)

        elif format_type == "numbered":
            # Create proper numbered hierarchy
            lines = notes.split('\n')
            current_numbers = [0, 0, 0]  # For three levels
            processed_lines = []
            for line in lines:
                line = line.strip()
                if line:
                    # Determine level based on indentation or existing numbers
                    if line[0].isdigit():
                        level = len(line.split('.')[0].split()) - 1
                    else:
                        level = 0
                        
                    # Update numbering
                    current_numbers[level] += 1
                    for i in range(level + 1, len(current_numbers)):
                        current_numbers[i] = 0
                        
                    # Format number based on level
                    if level == 0:
                        number = f"{current_numbers[0]}."
                    else:
                        number = '.'.join(str(n) for n in current_numbers[:level+1] if n > 0) + '.'
                        
                    # Add proper indentation
                    indent = "  " * level
                    processed_lines.append(f"{indent}{number} {line.lstrip('0123456789. ')}")
            return '\n'.join(processed_lines)

        elif format_type == "outline":
            # Create proper outline format with Roman numerals
            lines = notes.split('\n')
            current_level = 0
            processed_lines = []
            roman_numerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']
            current_numbers = {'I': 0, 'A': 0, '1': 0}
            
            for line in lines:
                line = line.strip()
                if line:
                    # Determine level and update numbering
                    if line[0].isalpha() and line[0].isupper():
                        current_level = 1
                        current_numbers['A'] += 1
                        current_numbers['1'] = 0
                        prefix = f"  {chr(64 + current_numbers['A'])}."
                    elif line[0].isdigit():
                        current_level = 2
                        current_numbers['1'] += 1
                        prefix = f"    {current_numbers['1']}."
                    else:
                        current_level = 0
                        current_numbers['I'] += 1
                        current_numbers['A'] = 0
                        current_numbers['1'] = 0
                        prefix = f"{roman_numerals[min(current_numbers['I']-1, len(roman_numerals)-1)]}."
                    
                    processed_lines.append(f"{prefix} {line.lstrip('IVX.ABC123 ')}")
            return '\n'.join(processed_lines)

        elif format_type == "mindmap":
            # Create a visual mind map structure
            lines = notes.split('\n')
            processed_lines = []
            current_level = 0
            
            for i, line in enumerate(lines):
                line = line.strip()
                if line:
                    if i == 0:  # Central topic
                        processed_lines.append(f"📌 {line}")
                        processed_lines.append("   │")
                    else:
                        # Determine level and add appropriate connectors
                        level = 1 if len(line) > 50 else 2 if len(line) > 30 else 3
                        if i == len(lines) - 1:  # Last line
                            connector = "   └──"
                        else:
                            connector = "   ├──"
                        indent = "   │   " * (level - 1)
                        processed_lines.append(f"{indent}{connector} {line}")
            return '\n'.join(processed_lines)

        elif format_type == "cornell":
            # Format as Cornell Notes
            sections = notes.split('\n\n')
            processed_lines = [
                "Cornell Notes",
                "═" * 50,
                "",
                "Main Ideas                    Notes",
                "──────────────               ─────────────────"
            ]
            
            # Process sections
            main_ideas = []
            notes_content = []
            summary = ""
            
            for section in sections:
                if "Main Idea:" in section or "Key Point:" in section:
                    main_ideas.append(section.replace("Main Idea:", "•").replace("Key Point:", "•"))
                elif "Summary:" in section:
                    summary = section.replace("Summary:", "").strip()
                else:
                    notes_content.append(section)
            
            # Format the layout
            max_lines = max(len(main_ideas), len(notes_content))
            for i in range(max_lines):
                main_idea = main_ideas[i] if i < len(main_ideas) else ""
                note = notes_content[i] if i < len(notes_content) else ""
                processed_lines.append(f"{main_idea:<30} {note}")
            
            # Add summary
            processed_lines.extend([
                "",
                "Summary",
                "───────",
                summary
            ])
            
            return '\n'.join(processed_lines)
            
        return notes  # Return as-is for unknown formats

    def basic_note_conversion(self, text, format_type):
        """Fast and efficient note conversion"""
        # Quick split and clean
        sentences = [s.strip() for s in text.replace('\n', ' ').split('.') if s.strip()]
        
        if format_type == "bullet":
            return '\n'.join(f"• {sentence}" for sentence in sentences)

        elif format_type == "mindmap":
            if not sentences:
                return "Empty text"
                
            # Create central topic
            result = [
                "📌 Main Topic: " + sentences[0],
                "   │"
            ]
            
            # Group related sentences
            current_branch = "   ├──🔸 "
            for i, sentence in enumerate(sentences[1:], 1):
                if i == len(sentences) - 1:  # Last sentence
                    result.append("   └──🔸 " + sentence)
                else:
                    result.append(current_branch + sentence)
                    if i % 3 == 0:  # Add sub-branch every 3 items
                        result.append("   │")
            
            return '\n'.join(result)

        elif format_type == "numbered":
            return '\n'.join(f"{i+1}. {sentence}" for i, sentence in enumerate(sentences))

        elif format_type == "outline":
            result = []
            for i, sentence in enumerate(sentences):
                if i < 10:
                    result.append(f"{'I' * (i + 1)}. {sentence}")
                else:
                    result.append(f"    {chr(65 + (i % 26))}. {sentence}")
            return '\n'.join(result)

        else:  # cornell
            if not sentences:
                return "Empty text"
            
            result = [
                "Cornell Notes",
                "═" * 50,
                "Main Ideas               Notes",
                "──────────               ─────"
            ]
            
            # Process sentences into main ideas and notes
            for i, sentence in enumerate(sentences):
                if i < 5:  # First 5 sentences become main ideas
                    main_idea = f"• Key Point {i+1}"
                    result.append(f"{main_idea:<20} {sentence}")
                else:  # Remaining sentences become supporting notes
                    result.append(f"{'':20} • {sentence}")
            
            # Add a summary section if there are sentences
            if sentences:
                result.extend([
                    "",
                    "Summary",
                    "───────",
                    "• " + sentences[0]  # Use first sentence as summary
                ])
            
            return '\n'.join(result)

    def clear_text(self):
        """Clear both input and output text areas"""
        self.input_text.delete("1.0", tk.END)
        self.output_text.delete("1.0", tk.END)
        self.status_label.config(text="Cleared all text")

    

    def export_notes(self):
        """Export notes to custom location"""
        try:
            from tkinter import filedialog
            
            notes_text = self.output_text.get("1.0", tk.END).strip()
            if not notes_text:
                messagebox.showwarning("Warning", "No notes to export", parent=self.window)
                return
                
            # Ask for save location
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[
                    ("Text files", "*.txt"),
                    ("Markdown files", "*.md"),
                    ("All files", "*.*")
                ],
                title="Export Notes"
            )
            
            if file_path:
                with open(file_path, "w", encoding="utf-8") as f:
                    f.write(notes_text)
                    
                self.status_label.config(text=f"Exported to {file_path}")
                messagebox.showinfo("Success", "Notes exported successfully!", parent=self.window)
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export notes: {str(e)}", parent=self.window)

    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')
class EmailSender:
    def __init__(self):
        self.email_config = {
            'smtp_server': 'smtp.gmail.com',
            'smtp_port': 587,
            'email': 'samiullas831@gmail.com',
            'password': 'hikk vnel ychc play'
        }

    def send_email(self, to_email, subject, body):
        """Send an email with the provided details"""
        try:
            msg = MIMEMultipart()
            msg['From'] = self.email_config['email']
            msg['To'] = to_email
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))

            server = smtplib.SMTP(self.email_config['smtp_server'], self.email_config['smtp_port'])
            server.starttls()
            server.login(self.email_config['email'], self.email_config['password'])
            server.send_message(msg)
            server.quit()
            return True, "Email sent successfully!"
        except Exception as e:
            return False, f"Failed to send email: {str(e)}"

class EmailWindow:
    def __init__(self, parent):
        # Create Toplevel window
        self.window = tk.Toplevel(parent)
        self.window.title("Send Email")
        self.window.geometry("500x600")
        self.window.configure(bg='#0C141F')  # Dark background
        
        # Make window modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Create email sender instance
        self.email_sender = EmailSender()
        
        # Create the GUI elements
        self.create_widgets()
        self.center_window()
        
    def create_widgets(self):
        # Main frame
        main_frame = tk.Frame(self.window, bg='#0C141F')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Content frame
        content_frame = tk.Frame(main_frame, bg='#0C141F')
        content_frame.pack(fill='both', expand=True)
        
        # To Email
        tk.Label(content_frame, text="To:", bg='#0C141F', fg='#00F2FF', 
                font=('Orbitron', 12)).pack(anchor='w', pady=(0, 5))
        self.to_entry = tk.Entry(content_frame, width=50,
                               bg='#1D2733',
                               fg='#00F2FF',
                               insertbackground='#00F2FF',
                               font=('Orbitron', 10))
        self.to_entry.pack(fill='x', pady=(0, 15))
        
        # Subject
        tk.Label(content_frame, text="Subject:", bg='#0C141F', fg='#00F2FF', 
                font=('Orbitron', 12)).pack(anchor='w', pady=(0, 5))
        self.subject_entry = tk.Entry(content_frame, width=50,
                                    bg='#1D2733',
                                    fg='#00F2FF',
                                    insertbackground='#00F2FF',
                                    font=('Orbitron', 10))
        self.subject_entry.pack(fill='x', pady=(0, 15))
        
        # Message
        tk.Label(content_frame, text="Message:", bg='#0C141F', fg='#00F2FF', 
                font=('Orbitron', 12)).pack(anchor='w', pady=(0, 5))
        self.message_text = tk.Text(content_frame, height=10, width=50,
                                  bg='#1D2733',
                                  fg='#00F2FF',
                                  insertbackground='#00F2FF',
                                  font=('Orbitron', 10))
        self.message_text.pack(fill='both', expand=True, pady=(0, 20))
        
        # Add a glowing border effect
        self.message_text.configure(highlightthickness=1,
                                  highlightcolor='#00F2FF',
                                  highlightbackground='#0066CC',
                                  relief='solid',
                                  borderwidth=1)
        
        # Buttons frame at the bottom
        button_frame = tk.Frame(main_frame, bg='#0C141F')
        button_frame.pack(side='bottom', fill='x', pady=(20, 0))
        
        # Send button
        self.send_button = tk.Button(
            button_frame,
            text="Send",
            command=self.send_email,
            bg='#00F2FF',
            fg='#0C141F',
            font=('Orbitron', 10, 'bold'),
            relief='flat',
            padx=20,
            pady=5,
            cursor='hand2'
        )
        self.send_button.pack(side='left', padx=10)
        
        # Cancel button
        self.cancel_button = tk.Button(
            button_frame,
            text="Cancel",
            command=self.window.destroy,
            bg='#00F2FF',
            fg='#0C141F',
            font=('Orbitron', 10, 'bold'),
            relief='flat',
            padx=20,
            pady=5,
            cursor='hand2'
        )
        self.cancel_button.pack(side='right', padx=10)
        
        # Add hover effects
        def on_enter(e, button):
            button.configure(bg='#66F9FF')
            
        def on_leave(e, button):
            button.configure(bg='#00F2FF')
            
        self.send_button.bind('<Enter>', lambda e: on_enter(e, self.send_button))
        self.send_button.bind('<Leave>', lambda e: on_leave(e, self.send_button))
        self.cancel_button.bind('<Enter>', lambda e: on_enter(e, self.cancel_button))
        self.cancel_button.bind('<Leave>', lambda e: on_leave(e, self.cancel_button))
        
    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')
        
    def send_email(self):
        to_email = self.to_entry.get()
        subject = self.subject_entry.get()
        body = self.message_text.get("1.0", tk.END)
        
        if not all([to_email, subject, body.strip()]):
            messagebox.showerror("Error", "Please fill in all fields", parent=self.window)
            return
            
        success, message = self.email_sender.send_email(to_email, subject, body)
        if success:
            messagebox.showinfo("Success", message, parent=self.window)
            self.window.destroy()
        else:
            messagebox.showerror("Error", message, parent=self.window)

class TranslatorWindow:
    def __init__(self, parent):
        self.window = tk.Toplevel(parent)
        self.window.title("Language Translator")
        self.window.geometry("800x600")
        self.window.configure(bg='#0c141f')  # Dark blue background
        
        # Button states
        self.PLAY_EMOJI = "▶️"
        self.STOP_EMOJI = "⏹️"
        self.is_translating = False
        
        # Configure Tron Legacy style
        style = ttk.Style()
        style.configure('Tron.TFrame', background='#0c141f')
        style.configure('Tron.TLabel', 
                       background='#0c141f', 
                       foreground='#00f2ff',  # Cyan text
                       font=('Orbitron', 10))
        style.configure('Tron.TButton',
                       background='#000000',
                       foreground='#00f2ff',
                       font=('Orbitron', 10))
        style.configure('Tron.TCombobox',
                       background='#1a2634',
                       foreground='#00f2ff',
                       selectbackground='#00f2ff',
                       selectforeground='#0c141f',
                       fieldbackground='#1a2634')
        
        # Dictionary mapping full language names to language codes
        self.language_dict = {
            "Afrikaans": "af", "Albanian": "sq", "Arabic": "ar", "Bengali": "bn",
            "Bulgarian": "bg", "Chinese (Simplified)": "zh-CN", "Croatian": "hr",
            "Czech": "cs", "Danish": "da", "Dutch": "nl", "English": "en",
            "Finnish": "fi", "French": "fr", "German": "de", "Greek": "el",
            "Gujarati": "gu", "Hindi": "hi", "Hungarian": "hu", "Indonesian": "id",
            "Italian": "it", "Japanese": "ja", "Kannada": "kn", "Korean": "ko",
            "Latin": "la", "Malay": "ms", "Malayalam": "ml", "Marathi": "mr",
            "Nepali": "ne", "Norwegian": "no", "Persian": "fa", "Polish": "pl",
            "Portuguese": "pt", "Punjabi": "pa", "Romanian": "ro", "Russian": "ru",
            "Serbian": "sr", "Slovak": "sk", "Spanish": "es", "Swedish": "sv",
            "Tamil": "ta", "Telugu": "te", "Thai": "th", "Turkish": "tr",
            "Ukrainian": "uk", "Urdu": "ur", "Vietnamese": "vi"
        }
        
        self.create_widgets()
        self.center_window()

    def create_widgets(self):
        # Main frame with padding
        main_frame = ttk.Frame(self.window, padding="20", style='Tron.TFrame')
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure grid
        self.window.columnconfigure(0, weight=1)
        self.window.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)

        # Source language selection
        ttk.Label(main_frame, text="From Language:", style='Tron.TLabel').grid(row=0, column=0, sticky=tk.W, pady=5)
        self.source_lang = ttk.Combobox(main_frame, values=sorted(self.language_dict.keys()), width=30, state='readonly', style='Tron.TCombobox')
        self.source_lang.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))
        self.source_lang.set("English")

        # Target language selection
        ttk.Label(main_frame, text="To Language:", style='Tron.TLabel').grid(row=1, column=0, sticky=tk.W, pady=5)
        self.target_lang = ttk.Combobox(main_frame, values=sorted(self.language_dict.keys()), width=30, state='readonly', style='Tron.TCombobox')
        self.target_lang.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5, padx=(10, 0))
        self.target_lang.set("Spanish")

        # Source text area
        ttk.Label(main_frame, text="Enter text to translate:", style='Tron.TLabel').grid(row=2, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        self.source_text = scrolledtext.ScrolledText(
            main_frame, wrap=tk.WORD, width=60, height=8,
            font=('Consolas', 10),
            bg='#1a2634',  # Darker blue
            fg='#00f2ff',  # Cyan text
            insertbackground='#00f2ff'  # Cyan cursor
        )
        self.source_text.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)

        # Buttons frame
        button_frame = ttk.Frame(main_frame, style='Tron.TFrame')
        button_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        # Custom button style
        self.translate_btn = tk.Button(
            button_frame,
            text=f"{self.PLAY_EMOJI} Translate",
            command=self.toggle_translate,
            font=('Orbitron', 10, 'bold'),
            bg='#1a2634',
            fg='#00f2ff',
            activebackground='#00f2ff',
            activeforeground='#0c141f',
            relief='flat',
            padx=20,
            cursor='hand2'
        )
        self.translate_btn.pack(side=tk.LEFT, padx=5)
        
        # Track translation state
        self.is_translating = False
        
        # Clear button
        clear_btn = tk.Button(
            button_frame,
            text="⌧ Clear",
            command=self.clear_text,
            font=('Orbitron', 10),
            bg='#1a2634',
            fg='#00f2ff',
            activebackground='#00f2ff',
            activeforeground='#0c141f',
            relief='flat',
            padx=20,
            cursor='hand2'
        )
        clear_btn.pack(side=tk.LEFT, padx=5)

        # Translated text area
        ttk.Label(main_frame, text="Translation:", style='Tron.TLabel').grid(row=5, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        self.translated_text = scrolledtext.ScrolledText(
            main_frame, wrap=tk.WORD, width=60, height=8,
            font=('Consolas', 10),
            bg='#1a2634',  # Darker blue
            fg='#00f2ff',  # Cyan text
            insertbackground='#00f2ff'  # Cyan cursor
        )
        self.translated_text.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        self.translated_text.configure(state='disabled')  # Make it read-only

    def toggle_translate(self):
        if not self.is_translating:
            self.translate()
            self.translate_btn.config(text=f"{self.STOP_EMOJI} Stop")
            self.is_translating = True
        else:
            self.stop_translation()
            self.translate_btn.config(text=f"{self.PLAY_EMOJI} Translate")
            self.is_translating = False

    def stop_translation(self):
        # Reset translation state
        self.translated_text.configure(state='normal')
        self.translated_text.delete("1.0", tk.END)
        self.translated_text.insert("1.0", "Translation stopped")
        self.translated_text.configure(state='disabled')

    def translate(self):
        try:
            source_text = self.source_text.get("1.0", tk.END).strip()
            if not source_text:
                messagebox.showwarning("Warning", "Please enter text to translate.")
                self.translate_btn.config(text=f"{self.PLAY_EMOJI} Translate")
                self.is_translating = False
                return

            source_lang_code = self.language_dict[self.source_lang.get()]
            target_lang_code = self.language_dict[self.target_lang.get()]

            # Configure translated text state for writing
            self.translated_text.configure(state='normal')
            self.translated_text.delete("1.0", tk.END)
            self.translated_text.insert("1.0", "⚡ Translating...")
            self.translated_text.update()

            # Perform translation
            translator = GoogleTranslator(source=source_lang_code, target=target_lang_code)
            translated = translator.translate(source_text)

            # Update the translated text
            self.translated_text.delete("1.0", tk.END)
            self.translated_text.insert("1.0", translated)
            
            # Reset button state after successful translation
            self.translate_btn.config(text=f"{self.PLAY_EMOJI} Translate")
            self.is_translating = False
            
        except Exception as e:
            self.translated_text.delete("1.0", tk.END)
            self.translated_text.insert("1.0", f"Translation failed: {str(e)}")
            self.translate_btn.config(text=f"{self.PLAY_EMOJI} Translate")
            self.is_translating = False
        finally:
            # Make translated text read-only again
            self.translated_text.configure(state='disabled')

    def clear_text(self):
        self.source_text.delete("1.0", tk.END)
        self.translated_text.configure(state='normal')
        self.translated_text.delete("1.0", tk.END)
        self.translated_text.configure(state='disabled')

    def on_closing(self):
        self.window.destroy()

    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f"{width}x{height}+{x}+{y}")


class ContactManager:
    def __init__(self, parent):
        self.window = tk.Toplevel(parent)
        self.window.title("Contact Manager")
        self.window.geometry("600x500")
        self.window.configure(bg='#1a237e')
        
        # Make window modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Initialize database
        self.db_file = os.path.join(os.path.expanduser('~'), 'Desktop', 'samcontact.db')
        self.init_database()
        
        # Create widgets
        self.create_widgets()
        
        # Center window
        self.center_window()

    def init_database(self):
        """Initialize the contacts database"""
        try:
            self.conn = sqlite3.connect(self.db_file)
            self.cursor = self.conn.cursor()
            
            # Create contacts table if it doesn't exist
            self.cursor.execute('''
                CREATE TABLE IF NOT EXISTS contacts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    number TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            self.conn.commit()
            logging.info("Database initialized successfully")
        except Exception as e:
            logging.error(f"Database initialization error: {str(e)}")
            messagebox.showerror("Database Error", f"Failed to initialize database: {str(e)}", parent=self.window)
    
    def create_widgets(self):
        # Main frame
        main_frame = tk.Frame(self.window, bg='#1a237e')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Title
        tk.Label(
            main_frame,
            text="Contact Manager",
            font=("Segoe UI", 24, "bold"),
            bg='#1a237e',
            fg='white'
        ).pack(pady=(0, 20))
        
        # Input frame
        input_frame = tk.Frame(main_frame, bg='#1a237e')
        input_frame.pack(fill='x', pady=10)
        
        # Name input
        tk.Label(
            input_frame,
            text="Name:",
            font=("Segoe UI", 12),
            bg='#1a237e',
            fg='white'
        ).pack(anchor='w')
        
        self.name_entry = tk.Entry(
            input_frame,
            font=("Segoe UI", 11),
            bg='#283593',
            fg='white',
            insertbackground='white'
        )
        self.name_entry.pack(fill='x', pady=(5, 10))
        
        # Number input
        tk.Label(
            input_frame,
            text="Number:",
            font=("Segoe UI", 12),
            bg='#1a237e',
            fg='white'
        ).pack(anchor='w')
        
        self.number_entry = tk.Entry(
            input_frame,
            font=("Segoe UI", 11),
            bg='#283593',
            fg='white',
            insertbackground='white'
        )
        self.number_entry.pack(fill='x', pady=(5, 10))
        
        # Buttons frame
        buttons_frame = tk.Frame(input_frame, bg='#1a237e')
        buttons_frame.pack(fill='x', pady=10)
        
        # Add button
        tk.Button(
            buttons_frame,
            text="Add Contact",
            command=self.add_contact,
            bg='#4CAF50',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        ).pack(side='left', padx=5)
        
        # Update button
        tk.Button(
            buttons_frame,
            text="Update Contact",
            command=self.update_contact,
            bg='#FF9800',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        ).pack(side='left', padx=5)
        
        # Delete button
        tk.Button(
            buttons_frame,
            text="Delete Contact",
            command=self.delete_contact,
            bg='#f44336',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        ).pack(side='left', padx=5)
        
        # Contacts list
        list_frame = tk.Frame(main_frame, bg='#1a237e')
        list_frame.pack(fill='both', expand=True, pady=10)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(list_frame)
        scrollbar.pack(side='right', fill='y')
        
        # Contacts listbox
        self.contacts_list = tk.Listbox(
            list_frame,
            bg='#283593',
            fg='white',
            font=("Segoe UI", 11),
            selectmode='single',
            yscrollcommand=scrollbar.set
        )
        self.contacts_list.pack(side='left', fill='both', expand=True)
        scrollbar.config(command=self.contacts_list.yview)
        
        # Bind selection event
        self.contacts_list.bind('<<ListboxSelect>>', self.on_select)
        
        # Load contacts
        self.load_contacts()
        
    def load_contacts(self):
        """Load contacts from database"""
        try:
            self.contacts_list.delete(0, tk.END)
            self.cursor.execute('SELECT name, number FROM contacts ORDER BY name')
            contacts = self.cursor.fetchall()
            
            for contact in contacts:
                self.contacts_list.insert(tk.END, f"{contact[0]} - {contact[1]}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load contacts: {str(e)}", parent=self.window)
    
    def add_contact(self):
        """Add a new contact"""
        try:
            name = self.name_entry.get().strip()
            number = self.number_entry.get().strip()
            
            if not name or not number:
                messagebox.showwarning("Warning", "Please enter both name and number", parent=self.window)
                return
                
            # Add to database
            self.cursor.execute('INSERT INTO contacts (name, number) VALUES (?, ?)', (name, number))
            self.conn.commit()
            
            # Clear inputs
            self.name_entry.delete(0, tk.END)
            self.number_entry.delete(0, tk.END)
            
            # Reload contacts
            self.load_contacts()
            
            messagebox.showinfo("Success", "Contact added successfully!", parent=self.window)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to add contact: {str(e)}", parent=self.window)
    
    def update_contact(self):
        """Update selected contact"""
        try:
            selection = self.contacts_list.curselection()
            if not selection:
                messagebox.showwarning("Warning", "Please select a contact to update", parent=self.window)
                return
                
            name = self.name_entry.get().strip()
            number = self.number_entry.get().strip()
            
            if not name or not number:
                messagebox.showwarning("Warning", "Please enter both name and number", parent=self.window)
                return
                
            # Get old name from selection
            old_contact = self.contacts_list.get(selection[0])
            old_name = old_contact.split(' - ')[0]
            
            # Update in database
            self.cursor.execute('UPDATE contacts SET name=?, number=? WHERE name=?', (name, number, old_name))
            self.conn.commit()
            
            # Clear inputs
            self.name_entry.delete(0, tk.END)
            self.number_entry.delete(0, tk.END)
            
            # Reload contacts
            self.load_contacts()
            
            messagebox.showinfo("Success", "Contact updated successfully!", parent=self.window)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update contact: {str(e)}", parent=self.window)
    
    def delete_contact(self):
        """Delete selected contact"""
        try:
            selection = self.contacts_list.curselection()
            if not selection:
                messagebox.showwarning("Warning", "Please select a contact to delete", parent=self.window)
                return
                
            if not messagebox.askyesno("Confirm", "Are you sure you want to delete this contact?", parent=self.window):
                return
                
            # Get name from selection
            contact = self.contacts_list.get(selection[0])
            name = contact.split(' - ')[0]
            
            # Delete from database
            self.cursor.execute('DELETE FROM contacts WHERE name=?', (name,))
            self.conn.commit()
            
            # Clear inputs
            self.name_entry.delete(0, tk.END)
            self.number_entry.delete(0, tk.END)
            
            # Reload contacts
            self.load_contacts()
            
            messagebox.showinfo("Success", "Contact deleted successfully!", parent=self.window)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete contact: {str(e)}", parent=self.window)
    
    def on_select(self, event):
        """Handle contact selection"""
        try:
            selection = self.contacts_list.curselection()
            if selection:
                contact = self.contacts_list.get(selection[0])
                name, number = contact.split(' - ')
                
                # Update entry fields
                self.name_entry.delete(0, tk.END)
                self.name_entry.insert(0, name)
                
                self.number_entry.delete(0, tk.END)
                self.number_entry.insert(0, number)
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to select contact: {str(e)}", parent=self.window)
    
    def center_window(self):
        """Center the window on screen"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')
class SummaryOutputWindow:
    def __init__(self, parent, summary_text):
        self.window = tk.Toplevel(parent)
        self.window.title("Generated Summary")
        self.window.geometry("600x400")
        self.window.configure(bg='#1a237e')
        
        # Make window modal
        self.window.transient(parent)
        self.window.grab_set()
        
        # Store the summary text
        self.summary_text = summary_text
        
        # Create the GUI elements
        self.create_widgets(summary_text)
        
        # Center the window
        self.center_window()

    def create_widgets(self, summary_text):
        # Main frame with padding
        main_frame = tk.Frame(self.window, bg='#1a237e')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # Title with better styling
        title_frame = tk.Frame(main_frame, bg='#1a237e')
        title_frame.pack(fill='x', pady=(0, 20))
        
        tk.Label(
            title_frame,
            text="Generated Summary",
            font=("Segoe UI", 24, "bold"),
            bg='#1a237e',
            fg='white'
        ).pack(side='left')
        
        # Buttons frame
        buttons_frame = tk.Frame(title_frame, bg='#1a237e')
        buttons_frame.pack(side='right')
        
        # Convert to Notes button
        self.notes_btn = tk.Button(
            buttons_frame,
            text="📝 Convert to Notes",
            command=self.convert_to_notes,
            bg='#4CAF50',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        )
        self.notes_btn.pack(side='right', padx=5)
        
        # Copy button
        self.copy_btn = tk.Button(
            buttons_frame,
            text="📋 Copy",
            command=self.copy_to_clipboard,
            bg='#FF9800',
            fg='white',
            font=("Segoe UI", 11, "bold"),
            relief='flat',
            cursor='hand2'
        )
        self.copy_btn.pack(side='right', padx=5)
        
        # Summary text area
        text_frame = tk.Frame(main_frame, bg='#1a237e')
        text_frame.pack(fill='both', expand=True)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(text_frame)
        scrollbar.pack(side='right', fill='y')
        
        # Text widget
        self.text = tk.Text(
            text_frame,
            wrap=tk.WORD,
            bg='#283593',
            fg='white',
            font=("Segoe UI", 11),
            insertbackground='white',
            selectbackground='#4361ee',
            selectforeground='white',
            yscrollcommand=scrollbar.set
        )
        self.text.pack(fill='both', expand=True)
        scrollbar.config(command=self.text.yview)
        
        # Insert the summary text
        self.text.insert('1.0', summary_text)
        self.text.config(state='disabled')
        
        # Status bar
        self.status_label = tk.Label(
            main_frame,
            text="Ready",
            font=("Segoe UI", 10),
            bg='#1a237e',
            fg='#8f9aff'
        )
        self.status_label.pack(pady=(10, 0))

    

    def copy_to_clipboard(self):
        """Copy summary to clipboard"""
        try:
            self.window.clipboard_clear()
            self.window.clipboard_append(self.summary_text)
            self.status_label.config(text="Copied to clipboard")
            messagebox.showinfo("Success", "Summary copied to clipboard!", parent=self.window)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to copy to clipboard: {str(e)}", parent=self.window)

    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')
        

class NotesOutputWindow:
    def __init__(self, parent, notes_text):
        self.window = tk.Toplevel(parent)
        self.window.title("Generated Smart Notes")
        self.window.configure(bg='#0C141F')  # Dark blue background
        
        # Set window size and position
        window_width = 800
        window_height = 600
        self.window.geometry(f"{window_width}x{window_height}")
        self.center_window()
        
        # Make window non-resizable
        self.window.resizable(False, False)
        
        self.create_widgets(notes_text)
        
    def create_widgets(self, notes_text):
        # Main container frame with dark theme
        main_frame = tk.Frame(self.window, bg='#0C141F')
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Title Label with glowing effect
        title_frame = tk.Frame(main_frame, bg='#0C141F')
        title_frame.pack(fill=tk.X, pady=(0, 15))
        
        title_label = tk.Label(title_frame, 
                             text="SMART NOTES OUTPUT",
                             font=('Orbitron', 16, 'bold'),
                             fg='#00F0FF',  # Cyan glow
                             bg='#0C141F')
        title_label.pack()
        
        # Create a frame for the text area with a glowing border
        text_container = tk.Frame(main_frame, 
                                bg='#00F0FF',  # Cyan border
                                padx=2, pady=2)  # Border thickness
        text_container.pack(fill=tk.BOTH, expand=True)
        
        # Inner frame for consistent background
        inner_frame = tk.Frame(text_container, bg='#0C141F')
        inner_frame.pack(fill=tk.BOTH, expand=True)
        
        # Text widget for displaying notes
        self.notes_text = tk.Text(inner_frame,
                                wrap=tk.WORD,
                font=('Consolas', 11),
                                bg='#0D1B2A',  # Darker blue for text area
                                fg='#00F0FF',  # Cyan text
                                insertbackground='#00F0FF',  # Cursor color
                                selectbackground='#1B3A5C',  # Selection background
                                selectforeground='#00F0FF',  # Selection text color
                                padx=10, pady=10,
                                relief=tk.FLAT,
                                bd=0)
        self.notes_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        # Insert the notes text
        self.notes_text.insert('1.0', notes_text)
        self.notes_text.config(state='disabled')  # Make read-only
        
        # Scrollbar with custom styling
        scrollbar = ttk.Scrollbar(inner_frame, 
                                orient='vertical', 
                                command=self.notes_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.notes_text['yscrollcommand'] = scrollbar.set
        
        # Bottom button frame
        button_frame = tk.Frame(main_frame, bg='#0C141F')
        button_frame.pack(fill=tk.X, pady=(15, 0))
        
        # Copy button with hover effect
        copy_button = tk.Button(button_frame,
                              text="COPY TO CLIPBOARD",
                              command=self.copy_to_clipboard,
                              font=('Orbitron', 10),
                              bg='#1B3A5C',  # Darker blue for button
                              fg='#00F0FF',
                              activebackground='#00F0FF',
                              activeforeground='#0C141F',
                              relief=tk.FLAT,
                              bd=0,
                              padx=20,
                              pady=5)
        copy_button.pack(side=tk.LEFT)
        
        # Add hover effects
        copy_button.bind('<Enter>', lambda e: copy_button.config(
            bg='#00F0FF', fg='#0C141F'))
        copy_button.bind('<Leave>', lambda e: copy_button.config(
            bg='#1B3A5C', fg='#00F0FF'))
        
        # Export button
        export_button = tk.Button(button_frame,
                                text="EXPORT",
                                command=self.export_notes,
                                font=('Orbitron', 10),
                                bg='#1B3A5C',  # Darker blue for button
                                fg='#00F0FF',
                                activebackground='#00F0FF',
                                activeforeground='#0C141F',
                                relief=tk.FLAT,
                                bd=0,
                                padx=20,
                                pady=5)
        export_button.pack(side=tk.RIGHT)
        
        # Add hover effects
        export_button.bind('<Enter>', lambda e: export_button.config(
            bg='#00F0FF', fg='#0C141F'))
        export_button.bind('<Leave>', lambda e: export_button.config(
            bg='#1B3A5C', fg='#00F0FF'))
        
    def copy_to_clipboard(self):
        notes_content = self.notes_text.get('1.0', tk.END)
        self.window.clipboard_clear()
        self.window.clipboard_append(notes_content)
        
        # Show a temporary success message
        temp_label = tk.Label(self.window,
                            text="Copied to clipboard!",
                            fg='#00F0FF',
                            bg='#0C141F',
                            font=('Orbitron', 10))
        temp_label.place(relx=0.5, rely=0.95, anchor='center')
        self.window.after(2000, temp_label.destroy)
        
    def export_notes(self):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            title="Export Notes"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as file:
                    notes_content = self.notes_text.get('1.0', tk.END)
                    file.write(notes_content)
                    
                # Show success message
                temp_label = tk.Label(self.window,
                                    text="Notes exported successfully!",
                                    fg='#00F0FF',
                                    bg='#0C141F',
                                    font=('Orbitron', 10))
                temp_label.place(relx=0.5, rely=0.95, anchor='center')
                self.window.after(2000, temp_label.destroy)
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to export notes: {str(e)}")
    
    def center_window(self):
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')

class ProgrammingWindow:
    def __init__(self, parent):
        self.window = tk.Toplevel(parent.root)
        self.window.title("AI Programming Assistant")
        self.window.geometry("1200x800")
        self.window.configure(bg="#0C141F")
        
        # Store the main application instance as parent
        self.main_app = parent
        self.buttons = {}
        
        # Initialize Gemini
        try:
            import google.generativeai as genai
            genai.configure(api_key="AIzaSyAqlSk_zL7ID0a_tiBP_E6sIurmXB43F4k")
            self.model = genai.GenerativeModel('gemini-2.0-flash')
        except Exception as e:
            messagebox.showerror("Error", f"Failed to initialize Gemini: {str(e)}")
            self.window.destroy()
            return
            
        # Initialize other attributes
        self.requirements_text = None
        self.code_display = None
        self.status_var = tk.StringVar()
        
        self.create_widgets()
        self.center_window()
        self.setup_bindings()
        
        # Make window modal
        self.window.transient(parent.root)
        self.window.grab_set()
        
        # Set window close handler
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_widgets(self):
        style = ttk.Style()
        style.configure("TRON.TButton",
                       padding=8,
                       font=('Orbitron', 10),
                       background="#00F0FF",
                       foreground="#0C141F")
        
        style.configure("TRON.TLabel",
                       font=('Orbitron', 12, 'bold'),
                       foreground="#00F0FF",
                       background="#0C141F")
        
        style.configure("TRON.TFrame",
                       background="#0C141F")
        
        # Main container with padding
        main_frame = ttk.Frame(self.window, padding="20", style="TRON.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Title with TRON style
        title_label = ttk.Label(main_frame, 
                              text="AI PROGRAMMING MATRIX", 
                              font=('Orbitron', 24, 'bold'),
                              foreground="#00F0FF",
                              background="#0C141F")
        title_label.pack(fill=tk.X, pady=(0, 20))

        # Requirements Frame with title
        req_label = ttk.Label(main_frame, 
                            text="PROGRAM REQUIREMENTS",
                            style="TRON.TLabel")
        req_label.pack(fill=tk.X, pady=(0, 5))

        req_frame = ttk.Frame(main_frame, style="TRON.TFrame")
        req_frame.pack(fill=tk.X, pady=(0, 15))

        self.requirements_text = tk.Text(req_frame, 
                              height=5, 
                              wrap=tk.WORD,
                              bg="#1A2030",
                              fg="#00F0FF",
                              insertbackground="#00F0FF",
                              font=('Share Tech Mono', 12),
                bd=2,
                              relief="solid",
                              highlightthickness=1,
                              highlightcolor="#00F0FF",
                              highlightbackground="#004A5D")
        self.requirements_text.pack(fill=tk.X, padx=5, pady=5)
        
        # Example requirements
        example_text = "Example: Create a Python program that reads a CSV file, processes the data, and generates a bar chart using matplotlib."
        self.requirements_text.insert('1.0', example_text)
        self.requirements_text.bind('<FocusIn>', lambda e: self.clear_example_text(e))

        # Buttons Frame with glowing effect
        btn_frame = ttk.Frame(main_frame, style="TRON.TFrame")
        btn_frame.pack(fill=tk.X, pady=(0, 15))

        button_configs = [
            ("GENERATE PROGRAM", self.generate_program, "Ctrl+Enter"),
            ("CLEAR ALL", self.clear_all, "Ctrl+L"),
            ("COPY CODE", self.copy_to_clipboard, "Ctrl+C"),
            ("SAVE CODE", self.save_code, "Ctrl+S")
        ]

        for text, command, shortcut in button_configs:
            btn = tk.Button(btn_frame,
                          text=f"{text}\n{shortcut}",
                          command=command,
                          font=('Orbitron', 9),
                          bg="#0C141F",
                          fg="#00F0FF",
                          activebackground="#00F0FF",
                          activeforeground="#0C141F",
                          relief="solid",
                          bd=1,
                          padx=15,
                          pady=5)
            btn.pack(side=tk.LEFT, padx=5, expand=True)
            
            # Store button reference
            self.buttons[text] = btn

            # Bind hover events for glow effect
            btn.bind('<Enter>', lambda e, b=btn: self.on_button_hover(e, b))
            btn.bind('<Leave>', lambda e, b=btn: self.on_button_leave(e, b))

        # Generated Code Frame
        code_label = ttk.Label(main_frame, 
                             text="GENERATED CODE OUTPUT", 
                             style="TRON.TLabel")
        code_label.pack(fill=tk.X, pady=(0, 5))

        code_frame = ttk.Frame(main_frame, style="TRON.TFrame")
        code_frame.pack(fill=tk.BOTH, expand=True)

        # Code display with syntax highlighting
        self.code_display = tk.Text(code_frame,
                                  wrap=tk.NONE,
                                  bg="#1A2030",
                                  fg="#00F0FF",
                                  insertbackground="#00F0FF",
                                  font=('Share Tech Mono', 12),
                                  bd=2,
                                  relief="solid",
                                  highlightthickness=1,
                                  highlightcolor="#00F0FF",
                                  highlightbackground="#004A5D")
        self.code_display.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Scrollbars with TRON style
        y_scrollbar = ttk.Scrollbar(code_frame, 
                                  orient=tk.VERTICAL,
                                  command=self.code_display.yview)
        y_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        x_scrollbar = ttk.Scrollbar(main_frame,
                                  orient=tk.HORIZONTAL,
                                  command=self.code_display.xview)
        x_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

        self.code_display.configure(yscrollcommand=y_scrollbar.set,
                                  xscrollcommand=x_scrollbar.set)

        # Status bar with TRON style
        status_bar = ttk.Label(main_frame,
                             textvariable=self.status_var,
                             style="TRON.TLabel",
                             relief=tk.SUNKEN,
                             anchor=tk.W)
        status_bar.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

        # Configure syntax highlighting
        self.setup_syntax_highlighting()

    def setup_syntax_highlighting(self):
        """Configure syntax highlighting tags"""
        # Keywords and control flow
        self.code_display.tag_configure(
            "keyword",
            foreground="#00F0FF",
            font=("Consolas", 11, "bold")
        )
        
        # Built-in functions and types
        self.code_display.tag_configure(
            "builtin",
            foreground="#FF00FF",
            font=("Consolas", 11, "bold")
        )
        
        # Strings
        self.code_display.tag_configure(
            "string",
            foreground="#FF9C00"
        )
        
        # Comments
        self.code_display.tag_configure(
            "comment",
            foreground="#0088CC",
            font=("Consolas", 11, "italic")
        )
        
        # Function names
        self.code_display.tag_configure(
            "function",
            foreground="#00FF9C"
        )
        
        # Class names
        self.code_display.tag_configure(
            "class",
            foreground="#FF10F0",
            font=("Consolas", 11, "bold")
        )
        
        # Numbers
        self.code_display.tag_configure(
            "number",
            foreground="#FFB000"
        )
        
        # Operators
        self.code_display.tag_configure(
            "operator",
            foreground="#FF3366",
            font=("Consolas", 11, "bold")
        )
        
        # Decorators
        self.code_display.tag_configure(
            "decorator",
            foreground="#00FFCC",
            font=("Consolas", 11, "italic")
        )
        
        # Type hints
        self.code_display.tag_configure(
            "type_hint",
            foreground="#BB86FC",
            font=("Consolas", 11, "bold")
        )
        
        # Special methods
        self.code_display.tag_configure(
            "special",
            foreground="#FF5000",
            font=("Consolas", 11, "bold")
        )

    def generate_program(self):
        loading_label = None
        try:
            # Get requirements from text area
            requirements = self.requirements_text.get("1.0", tk.END).strip()
            if not requirements or requirements == "Example: Create a Python program that reads a CSV file, processes the data, and generates a bar chart using matplotlib.":
                self.show_notification("Please enter program requirements first!")
                return
           
            # Disable generate button while processing
            self.buttons["GENERATE PROGRAM"].configure(state="disabled")
            
            # Show loading indicator
            loading_label = tk.Label(self.window, text="Generating code...", fg="#00ff00", bg="#1e1e1e")
            loading_label.place(relx=0.5, rely=0.4, anchor="center")
            self.window.update()
            
            # Clear existing text and tags in code display
            self.code_display.delete("1.0", tk.END)
            for tag in self.code_display.tag_names():
                self.code_display.tag_remove(tag, "1.0", tk.END)

            # Get custom prompt from main app
            custom_prompt = self.main_app.load_prompt('programming')
            if custom_prompt:
                prompt = f"""{custom_prompt},

Requirements:
{requirements}

Please ensure:
- Clean, well-documented code
- Proper error handling
- PEP 8 style compliance
- 4 spaces for indentation
- Spaces around operators
- Descriptive variable names
- Type hints where appropriate
- Professional 

Return only the code, no explanations."""
            else:
                prompt = f"""Generate a Python Program based on these requirements:
{requirements}

Please ensure:
- Clean, well-documented code
- Proper error handling
- PEP 8 style compliance
- Professional code structure

Return only the code, no explanations."""

            # Generate code using Gemini
            response = self.model.generate_content(prompt)
            generated_code = response.text.strip()
            
            # Apply syntax highlighting to the generated code
            self.apply_syntax_highlighting(generated_code)
            
            # Show success notification
            self.show_notification("Program generated successfully! Use Ctrl+S to save or Ctrl+C to copy.")
            
        except Exception as e:
            self.show_notification(f"Error generating program: {str(e)}")
            logging.error(f"Error in generate_program: {str(e)}")
        finally:
            # Re-enable generate button
            if "GENERATE PROGRAM" in self.buttons:
                self.buttons["GENERATE PROGRAM"].configure(state="normal")
            # Safely destroy loading label if it exists
            if loading_label and loading_label.winfo_exists():
                loading_label.destroy()

    def apply_syntax_highlighting(self, code):
        """Apply syntax highlighting to the code"""
        # Clear existing text and tags
        self.code_display.delete("1.0", tk.END)
        
        import re
        
        # Python keywords, built-ins, and special methods
        keywords = ["def", "class", "import", "from", "return", "if", "else", "elif",
                   "try", "except", "finally", "for", "while", "in", "and", "or", 
                   "not", "is", "with", "as", "raise", "break", "continue", "pass",
                   "lambda", "assert", "del", "yield", "async", "await"]
                   
        builtins = ["True", "False", "None", "print", "len", "range", "str", "int",
                    "float", "list", "dict", "set", "tuple", "sum", "min", "max",
                    "enumerate", "zip", "map", "filter", "any", "all", "round", "abs"]
                    
        operators = ["+", "-", "*", "/", "//", "%", "**", "=", "==", "!=", "<", ">",
                    "<=", ">=", "+=", "-=", "*=", "/=", "&", "|", "^", "~", "<<", ">>"]
                    
        special_methods = [f"__{name}__" for name in ["init", "str", "repr", "len", 
                         "getitem", "setitem", "delitem", "iter", "next", "enter",
                         "exit", "call", "add", "sub", "mul", "div", "mod", "pow"]]
        
        # Split code into lines
        lines = code.split("\n")
        
        for line in lines:
            # Get the indentation level
            indent_match = re.match(r'^(\s*)', line)
            indent = indent_match.group(1) if indent_match else ''
            self.code_display.insert(tk.END, indent)
            
            # Handle full-line comments
            if line.strip().startswith("#"):
                self.code_display.insert(tk.END, line.strip() + "\n", "comment")
                continue
            
            # Handle decorators
            if line.strip().startswith("@"):
                self.code_display.insert(tk.END, line.strip() + "\n", "decorator")
                continue
                
            # Handle other syntax
            words = re.findall(r'[\w._]+|"[^"]*"|\'[^\']*\'|#.*|[^\w\s]|\s+', line.strip())
            
            i = 0
            while i < len(words):
                word = words[i]
                
                if word.isspace():
                    self.code_display.insert(tk.END, word)
                elif word in keywords:
                    self.code_display.insert(tk.END, word, "keyword")
                elif word in builtins:
                    self.code_display.insert(tk.END, word, "builtin")
                elif word in special_methods:
                    self.code_display.insert(tk.END, word, "special")
                elif word in operators:
                    self.code_display.insert(tk.END, word, "operator")
                elif word.startswith(("'", '"')):
                    self.code_display.insert(tk.END, word, "string")
                elif word.startswith("#"):
                    self.code_display.insert(tk.END, word, "comment")
                elif re.match(r'^[0-9]+(\.[0-9]+)?$', word):
                    self.code_display.insert(tk.END, word, "number")
                elif re.match(r'^[A-Z][a-zA-Z0-9]*$', word):
                    self.code_display.insert(tk.END, word, "class")
                elif re.match(r'^[a-z][a-zA-Z0-9_]*\($', word):
                    self.code_display.insert(tk.END, word, "function")
                elif re.match(r'^[A-Z][a-zA-Z0-9_]*(\[.*\])?$', word):
                    self.code_display.insert(tk.END, word, "type_hint")
                else:
                    self.code_display.insert(tk.END, word)

                i += 1
            
            self.code_display.insert(tk.END, "\n")

    def setup_bindings(self):
        """Setup keyboard shortcuts"""
        self.window.bind('<Control-Return>', lambda e: self.generate_program())
        self.window.bind('<Control-l>', lambda e: self.clear_all())
        self.window.bind('<Control-c>', lambda e: self.copy_to_clipboard())
        self.window.bind('<Control-s>', lambda e: self.save_code())

    def clear_example_text(self, event):
        """Clear example text when input field is focused"""
        if self.requirements_text.get('1.0', tk.END).strip() == "Example: Create a Python program that reads a CSV file, processes the data, and generates a bar chart using matplotlib.":
            self.requirements_text.delete('1.0', tk.END)

    def on_button_hover(self, event, button):
        """Create glowing effect on hover"""
        button.config(
            bg="#00F0FF",
            fg="#0C141F",
            bd=2,
            highlightbackground="#00F0FF",
            highlightthickness=2
        )

    def on_button_leave(self, event, button):
        """Remove glowing effect on leave"""
        button.config(
            bg="#0C141F",
            fg="#00F0FF",
            bd=1,
            highlightbackground="#0C141F",
            highlightthickness=1
        )

    def copy_to_clipboard(self):
        """Copy generated code to clipboard"""
        code = self.code_display.get("1.0", tk.END).strip()
        if code:
            self.window.clipboard_clear()
            self.window.clipboard_append(code)
            self.show_notification("Code copied to clipboard!")
        else:
            self.show_notification("No code to copy!")

    def save_code(self, event=None):
        """Save generated code to file"""
        code = self.code_display.get("1.0", tk.END).strip()
        if not code:
            self.show_notification("No code to save!")
            return
            
        file_path = filedialog.asksaveasfilename(
            defaultextension=".py",
            filetypes=[("Python files", "*.py"), ("All files", "*.*")],
            title="Save Generated Code"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(code)
                self.show_notification(f"Code saved successfully to {file_path}")
            except Exception as e:
                self.show_notification(f"Error saving file: {str(e)}")
                messagebox.showerror("Save Error", f"Failed to save file: {str(e)}")

    def clear_all(self):
        """Clear all text fields"""
        self.requirements_text.delete("1.0", tk.END)
        self.code_display.delete("1.0", tk.END)
        self.status_var.set("")
        # Reset example text
        self.requirements_text.insert('1.0', "Example: Create a Python program that reads a CSV file, processes the data, and generates a bar chart using matplotlib.")

    def show_notification(self, message):
        """Show a notification message in the status bar"""
        if hasattr(self, 'status_var'):
            self.status_var.set(message)
        else:
            messagebox.showinfo("Notification", message)

    def center_window(self):
        """Center the window on the screen"""
        self.window.update_idletasks()
        width = self.window.winfo_width()
        height = self.window.winfo_height()
        x = (self.window.winfo_screenwidth() // 2) - (width // 2)
        y = (self.window.winfo_screenheight() // 2) - (height // 2)
        self.window.geometry(f'{width}x{height}+{x}+{y}')

    def on_closing(self):
        """Handle window closing"""
        self.window.destroy()

def check_dependencies():
    """Check if all required dependencies are available"""
    try:
        required_modules = [
            'speech_recognition', 'pyttsx3', 'pyautogui', 'pillow', 'numpy',
            'requests', 'psutil', 'googletrans', 'transformers', 'torch'
        ]
        missing_modules = []
        
        for module in required_modules:
            try:
                importlib.import_module(module)
            except ImportError:
                missing_modules.append(module)
        
        if missing_modules:
            error_msg = f"Missing required dependencies: {', '.join(missing_modules)}"
            logging.error(error_msg)
            messagebox.showerror("Dependency Error", error_msg)
            return False
        return True
    except Exception as e:
        logging.critical(f"Fatal error checking dependencies: {str(e)}")
        messagebox.showerror("Critical Error", f"Failed to check dependencies: {str(e)}")
        return False
def get_system_info():
    """Get basic system information with error handling"""
    info = {}
    try:
        info['system'] = platform.system()
    except Exception as e:
        info['system'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['version'] = platform.version()
    except Exception as e:
        info['version'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['machine'] = platform.machine()
    except Exception as e:
        info['machine'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['processor'] = platform.processor()
    except Exception as e:
        info['processor'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['python_version'] = platform.python_version()
    except Exception as e:
        info['python_version'] = f"Unknown (Error: {str(e)})"
    
    return info

def create_backup():
    """Create backup of important files"""
    try:
        app_dir = get_app_directory()
        backup_dir = os.path.join(app_dir, "backups")
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)
            
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(backup_dir, f"backup_{timestamp}.zip")
        
        # Add files to backup
        files_to_backup = [
            os.path.join(get_log_directory(), "assistant_log.txt"),
            os.path.join(app_dir, "data")
        ]
        
        import zipfile
        with zipfile.ZipFile(backup_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file in files_to_backup:
                if os.path.exists(file):
                    if os.path.isfile(file):
                        try:
                            zipf.write(file, os.path.basename(file))
                            logging.info(f"Backed up file: {file}")
                        except Exception as e:
                            logging.warning(f"Failed to backup file {file}: {str(e)}")
                    elif os.path.isdir(file):
                        for root, dirs, files in os.walk(file):
                            for f in files:
                                try:
                                    file_path = os.path.join(root, f)
                                    arcname = os.path.relpath(file_path, os.path.dirname(file))
                                    zipf.write(file_path, arcname)
                                    logging.info(f"Backed up file: {file_path}")
                                except Exception as e:
                                    logging.warning(f"Failed to backup file {file_path}: {str(e)}")
                                
        logging.info(f"Backup created successfully: {backup_file}")
        return backup_file
    except Exception as e:
        logging.error(f"Backup creation failed: {str(e)}")
        return None
def initialize_auto_login_db():
    """Initialize the auto login database."""
    try:
        conn = sqlite3.connect('auto_login.db')
        cursor = conn.cursor()
        
        # Create table for storing credentials
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS credentials (
                id INTEGER PRIMARY KEY,
                website TEXT NOT NULL,
                email TEXT NOT NULL,
                password TEXT NOT NULL
            )
        ''')
        conn.commit()
        conn.close()
    except Exception as e:
        logging.error(f"Error initializing auto login database: {str(e)}")

def initialize_url_db():
    """Initialize the URL database."""
    try:
        conn = sqlite3.connect('url.db')
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS urls (
            id INTEGER PRIMARY KEY,
            website TEXT NOT NULL UNIQUE,
            url TEXT NOT NULL
        )''')
        conn.commit()
        conn.close()
    except Exception as e:
        logging.error(f"Error initializing URL database: {str(e)}")

def add_url(website, url):
    """Add a new URL to the database."""
    try:
        conn = sqlite3.connect('url.db')
        cursor = conn.cursor()
        cursor.execute('INSERT OR REPLACE INTO urls (website, url) VALUES (?, ?)', (website.lower(), url))
        conn.commit()
        conn.close()
    except Exception as e:
        logging.error(f"Error adding URL: {str(e)}")

def get_url(website):
    """Retrieve a URL from the database by website name."""
    try:
        conn = sqlite3.connect('url.db')
        cursor = conn.cursor()
        cursor.execute('SELECT url FROM urls WHERE website = ?', (website.lower(),))
        result = cursor.fetchone()
        conn.close()
        return result[0] if result else None
    except Exception as e:
        logging.error(f"Error retrieving URL: {str(e)}")
        return None
initialize_url_db()

if __name__ == "__main__":
    try:
        # Create required directories first
        initialize_auto_login_db()
        if not create_required_directories():
            print("Warning: Some directories could not be created")
        
        # Setup logging
        if not setup_logging():
            print("Warning: Using fallback logging configuration")
        
        # Continue with the rest of your application
        root = tk.Tk()
        app = VoiceAssistant(root)
        root.mainloop()
    except Exception as e:
        print(f"Fatal error during startup: {str(e)}")
        sys.exit(1)

def format_time(seconds):
    """Convert seconds to formatted time string"""
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{int(hours):02d}:{int(minutes):02d}"




def check_dependencies():
    """Check if all required dependencies are available"""
    try:
        required_modules = [
            'speech_recognition', 'pyttsx3', 'pyautogui', 'pillow', 'numpy',
            'requests', 'psutil', 'googletrans', 'transformers', 'torch'
        ]
        missing_modules = []
        
        for module in required_modules:
            try:
                importlib.import_module(module)
            except ImportError:
                missing_modules.append(module)
        
        if missing_modules:
            error_msg = f"Missing required dependencies: {', '.join(missing_modules)}"
            logging.error(error_msg)
            messagebox.showerror("Dependency Error", error_msg)
            return False
        return True
    except Exception as e:
        logging.critical(f"Fatal error checking dependencies: {str(e)}")
        messagebox.showerror("Critical Error", f"Failed to check dependencies: {str(e)}")
        return False
def get_system_info():
    """Get basic system information with error handling"""
    info = {}
    try:
        info['system'] = platform.system()
    except Exception as e:
        info['system'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['version'] = platform.version()
    except Exception as e:
        info['version'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['machine'] = platform.machine()
    except Exception as e:
        info['machine'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['processor'] = platform.processor()
    except Exception as e:
        info['processor'] = f"Unknown (Error: {str(e)})"
    
    try:
        info['python_version'] = platform.python_version()
    except Exception as e:
        info['python_version'] = f"Unknown (Error: {str(e)})"
    
    return info
def create_required_directories():
    """Create necessary directories if they don't exist"""
    directories = ['logs', 'screenshots', 'data']
    for directory in directories:
        if not os.path.exists(directory):
            os.makedirs(directory)

def setup_logging():
    """Setup logging configuration"""
    logging.basicConfig(
        filename='logs/assistant.log',
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

def create_backup():
    """Create backup of important files"""
    try:
        app_dir = get_app_directory()
        backup_dir = os.path.join(app_dir, "backups")
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)
            
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = os.path.join(backup_dir, f"backup_{timestamp}.zip")
        
        # Add files to backup
        files_to_backup = [
            os.path.join(get_log_directory(), "assistant_log.txt"),
            os.path.join(app_dir, "data")
        ]
        
        import zipfile
        with zipfile.ZipFile(backup_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for file in files_to_backup:
                if os.path.exists(file):
                    if os.path.isfile(file):
                        try:
                            zipf.write(file, os.path.basename(file))
                            logging.info(f"Backed up file: {file}")
                        except Exception as e:
                            logging.warning(f"Failed to backup file {file}: {str(e)}")
                    elif os.path.isdir(file):
                        for root, dirs, files in os.walk(file):
                            for f in files:
                                try:
                                    file_path = os.path.join(root, f)
                                    arcname = os.path.relpath(file_path, os.path.dirname(file))
                                    zipf.write(file_path, arcname)
                                    logging.info(f"Backed up file: {file_path}")
                                except Exception as e:
                                    logging.warning(f"Failed to backup file {file_path}: {str(e)}")
                                
        logging.info(f"Backup created successfully: {backup_file}")
        return backup_file
    except Exception as e:
        logging.error(f"Backup creation failed: {str(e)}")
        return None

if __name__ == "__main__":
    try:
        # Create required directories first
        if not create_required_directories():
            print("Warning: Some directories could not be created")
        
        # Setup logging
        if not setup_logging():
            print("Warning: Using fallback logging configuration")
        
        # Continue with the rest of your application
        root = tk.Tk()
        app = VoiceAssistant(root)
        root.mainloop()
    except Exception as e:
        print(f"Fatal error during startup: {str(e)}")
        sys.exit(1)

# Additional utility functions that might be needed

def format_time(seconds):
    """Convert seconds to formatted time string"""
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{int(hours):02d}:{int(minutes):02d}"



